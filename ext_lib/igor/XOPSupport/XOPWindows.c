/*	This file contains utilities for XOPs that create windows.	It includes utilities for IGOR text windows (TU windows).		HR, 10/8/96: Split these routines out from XOPSupport.c.*/#include "XOPStandardHeaders.h"			// Include ANSI headers, Mac headers, IgorXOP.h, XOP.h and XOPSupport.h#include "XOPStructureAlignmentTwoByte.h"	// All structures passed between Igor and XOP are two-byte aligned./*	GetActiveWindowRef()		Returns an XOP_WINDOW_REF for the active window. An XOP_WINDOW_REF is a	WindowPtr on Macintosh and an HWND on Windows. The returned value could be	NULL and it could be a reference to a window that is not owned by the calling	XOP.			This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/XOP_WINDOW_REFGetActiveWindowRef(void){	#ifdef _MACINTOSH_		return FrontNonFloatingWindow();	#endif	#ifdef _WINDOWS_		HWND hwndActive;				/*	GetActiveWindows does not work when the window is an MDI child.			The Windows documentation is characteristically unclear about this.		*/		hwndActive = (HWND)SendMessage(IgorClientHWND(), WM_MDIGETACTIVE, 0, 0);		return hwndActive;		#endif}	/*	IsXOPWindowActive(windowRef)	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/intIsXOPWindowActive(XOP_WINDOW_REF windowRef){	if (windowRef == NULL)		return 0;	if (windowRef == GetActiveWindowRef())		return 1;	return 0;}/*	ShowXOPWindow(windowRef)	Shows the window without activating it. Call this in response to the XOP_SHOW_WINDOW	message from Igor.		This routine was added in XOP Toolkit release 5.07 but works with all supported	versions of Igor.*/voidShowXOPWindow(XOP_WINDOW_REF windowRef){	#ifdef _MACINTOSH_		ShowWindow(windowRef);	#endif	#ifdef _WINDOWS_		ShowWindow(windowRef, SW_SHOW);	#endif}/*	HideXOPWindow(windowRef)	Hides the window without sending it to the bottom of the desktop. Call this in response	to the XOP_SHOW_WINDOW message from Igor.	This routine was added in XOP Toolkit release 5.07 but works with all supported	versions of Igor.*/voidHideXOPWindow(XOP_WINDOW_REF windowRef){	#ifdef _MACINTOSH_		HideWindow(windowRef);	#endif	#ifdef _WINDOWS_		ShowWindow(windowRef, SW_HIDE);	#endif}/*	ShowAndActivateXOPWindow(windowRef)	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidShowAndActivateXOPWindow(XOP_WINDOW_REF windowRef){	#ifdef _MACINTOSH_		ShowWindow(windowRef);		SelectWindow(windowRef);	#endif	#ifdef _WINDOWS_		ShowWindow(windowRef, SW_SHOW);		SetWindowPos(windowRef, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);	#endif}/*	HideAndDeactivateXOPWindow(windowRef)	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidHideAndDeactivateXOPWindow(XOP_WINDOW_REF windowRef){	#ifdef _MACINTOSH_		HideWindow(windowRef);		SendBehind(windowRef, NULL);	#endif	#ifdef _WINDOWS_		HWND nextHWND;		int isActive;				nextHWND = GetWindow(windowRef, GW_HWNDNEXT);		isActive = IsXOPWindowActive(windowRef);		ShowWindow(windowRef, SW_HIDE);		if (isActive) {			// SetActiveWindow(nextHWND);	// Does not work when hwnd is MDI child, although it should, according to Windows documentation.			SetWindowPos(nextHWND, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);		}	#endif}/*	SetXOPWindowTitle(windowRef,  title)	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidSetXOPWindowTitle(XOP_WINDOW_REF windowRef, const char* title){	#ifdef _MACINTOSH_	{		unsigned char pTitle[256];		CopyCStringToPascal(title, pTitle);		SetWTitle(windowRef, pTitle);	}	#endif	#ifdef _WINDOWS_		SetWindowText(windowRef, title);	#endif}/*	GetXOPWindowPositionAndState(theWindow, r, winStatePtr)		Returns the XOP window's position on the screen in pixels and its state.	Used with SetXOPWindowPositionAndState to save and restore a window's position	and state.		Use this routine when you need to store a window position in a platform-dependent	way, for example, in a preference file. Use GetXOPWindowIgorPositionAndState	to store a window position in a platform-independent way, for example, in a	/W=(left,top,right,bottom) flag.		On Macintosh, the returned coordinates specify the location of the window's	content region in global coordinates. Bit 0 of *winStatePtr is set if the	window is visible and cleared if it is hidden. All other bits are set to 0.		On Windows, the returned coordinates specify the the location of the entire	window in its normal state relative the the top/left corner of the Igor MDI	client window. Bit 0 of *winStatePtr is set if the window is visible and	cleared if it is hidden. Bit 1 of *winStatePtr is set if the window is minimize	and cleared if it is not minimized. All other bits are set to 0.		On either platform, the returned rectangle is a Macintosh rectangle.	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidGetXOPWindowPositionAndState(XOP_WINDOW_REF windowRef, Rect* r, int* winStatePtr){	#ifdef _MACINTOSH_		GrafPtr thePort;		GrafPtr savePort;		thePort = GetWindowPort(windowRef);		*winStatePtr = IsWindowVisible(windowRef) ? 1:0;		GetPortBounds(thePort, r);				// Content rectangle in local coordinates.		GetPort(&savePort);		SetPort(thePort);		LocalToGlobal((Point *)&r->top);		LocalToGlobal((Point *)&r->bottom);		SetPort(savePort);	#endif		#ifdef _WINDOWS_		WINDOWPLACEMENT wp;				*winStatePtr = IsWindowVisible(windowRef) ? 1:0;		if (IsIconic(windowRef))			*winStatePtr |= 2;		wp.length = sizeof(wp);		GetWindowPlacement(windowRef, &wp);		WinRectToMacRect(&wp.rcNormalPosition, r);	#endif}/*	SetXOPWindowPositionAndState(theWindow, r, winState)		Moves the XOP window to the position indicated by r and sets its state.	Used with GetXOPWindowPositionAndState to save and restore a window's position	and state.		Use this routine when you need to restore a window position in a platform-dependent	way, for example, in a preference file. Use SetXOPWindowIgorPositionAndState	to restore a window position in a platform-independent way, for example, in a	/W=(left,top,right,bottom) flag.		See GetXOPWindowPositionAndState for a discussion of the units of the rectangle	and the meaning of the winState parameter.		This routine makes an effort to prevent the window from becoming inaccessible	because it is off-screen.	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidSetXOPWindowPositionAndState(XOP_WINDOW_REF windowRef, Rect* r, int winState){	#ifdef _MACINTOSH_		int left, right, top, bottom, width, height;		RgnHandle grayRgn;		Rect frameRect;		if ((winState & 1) == 0)			HideWindow(windowRef);		left = r->left;		right = r->right;		top = r->top;		bottom = r->bottom;		width = right - left;		height = bottom - top;				SetRect(&frameRect, left, top-20, right, top);		// Roughly the window frame rect.		InsetRect(&frameRect, 5, 5);						// Make sure at least 5 pixels of frame are on the desktop.		grayRgn = GetGrayRgn();		if (!RectInRgn(&frameRect, grayRgn)) {				// Window frame is completely out of desktop?			Rect bounds;			GetRegionBounds(grayRgn, &bounds);			left = bounds.left + 3;			top = bounds.top + 23;			right = left + width;			bottom = top + height;		}		if (width < 10)			width = 10;		if (height < 10)			height = 10;		MoveWindow(windowRef, left, top, 0);		SizeWindow(windowRef, width, height, -1);		if ((winState & 1) != 0)			ShowWindow(windowRef);	#endif		#ifdef _WINDOWS_		WINDOWPLACEMENT wp;		RECT childRECT, mdiClientRECT;		if ((winState & 1) == 0)			ShowWindow(windowRef, SW_HIDE);				wp.length = sizeof(wp);		GetWindowPlacement(windowRef, &wp);		wp.flags = 0;		if (winState & 2) {						// Want to minimize?			wp.showCmd = SW_MINIMIZE;		}		else {			if ((winState & 1) != 0)				wp.showCmd = SW_SHOWNORMAL;			else				wp.showCmd = SW_HIDE;		}				MacRectToWinRect(r, &childRECT);		GetClientRect(IgorClientHWND(), &mdiClientRECT);		if (childRECT.top < 0)			OffsetRect(&childRECT, 0, -childRECT.top);		if (childRECT.top > mdiClientRECT.bottom)			OffsetRect(&childRECT, 0, -(childRECT.top - mdiClientRECT.bottom + 10));		if (childRECT.right < 0)			OffsetRect(&childRECT, -childRECT.right + 10, 0);		if (childRECT.left > mdiClientRECT.right)			OffsetRect(&childRECT, -(childRECT.left - mdiClientRECT.right + 10), 0);		wp.rcNormalPosition = childRECT;				SetWindowPlacement(windowRef, &wp);	#endif}/*	TransformWindowCoordinates(mode, coords)	Transforms window coordinates from screen pixels into Igor coordinates or	from Igor coordinates into screen pixels. This routine is intended for use	in command line operations that set a window position, for example, for	an operation that supports a /W=(left,top,right,bottom) flag. We want	a given command containing a /W flag to produce approximately the same result	on Macintosh and on Windows. This is complicated because of differences in	the way each platform represents the position of windows.	Igor coordinates are a special kind of coordinates that were designed to solve	this problem. Igor coordinates are in units of points, not pixels. On Macintosh,	Igor coordinates are the same as global coordinates - points relative to the top/left	corner of the main screen. On Windows, Igor coordinates are points relative to a spot	20 points above the top/left corner of the MDI client area. As a result of this	definition, the vertical coordinate 20 corresponds to the point just below the main	menu bar on both platforms.	The use of Igor coordinates in commands means that you can transport files and	commands from one platform to the other and get reasonable results. However,	the results may not be exactly what you expect. The reason for this is that	Igor positions the "content" portion of a window. The content portion is the	portion of the window exclusive of the frame and title bar (border and caption	in Windows terminology). Because the size of window borders and captions is	variable on Windows, when you open a Macintosh experiment on Windows or vice versa,	the window positions might be slightly different from what you would expect. 		We keep coordinates in floating point because, to accurately reposition a	window, we need to use fractional points in /W=(left,top,right,bottom) flags.		mode is		0:		Transform from screen pixels into Igor coordinates.		1:		Transform from Igor coordinates into screen pixels.			For TransformWindowCoordinates, screen pixels are in global coordinates on	Macintosh (relative to the top/left corner of the main screen) and are in	MDI-client coordinates (relative to the top/left corner of the MDI client	window, not the MDI frame) on Windows.  			coords is an array of window coordinates. It is both an input and an output.	The coordinates specify the location of the window's content area only. That	is, it excludes the title bar and the frame.		coords[0] is the location of the left edge of the window content area.	coords[1] is the location of the top edge of the window content area.	coords[2] is the location of the right edge of the window content area.	coords[3] is the location of the bottom edge of the window content area.		On Macintosh, screen coordinates and Igor coordinates are identical. Thus, this	routine is a NOP on Macintosh.	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidTransformWindowCoordinates(int mode, double coords[4]){	#ifdef _MACINTOSH_		// [		#pragma unused(mode)		#pragma unused(coords)	#endif					// ]	#ifdef _WINDOWS_		// [		HDC screenDC;		int hPixelsPerInch, vPixelsPerInch;		int vOffsetInPoints;			screenDC = GetDC(NULL);		hPixelsPerInch = GetDeviceCaps(screenDC,LOGPIXELSX);		vPixelsPerInch = GetDeviceCaps(screenDC,LOGPIXELSY);		ReleaseDC(NULL,screenDC);			vOffsetInPoints = 20;				if (mode == 0) {			// Transform from screen pixels into IGOR coordinates.			coords[0] = 72.0 * (coords[0] / hPixelsPerInch);			coords[1] = vOffsetInPoints + 72.0 * (coords[1] / vPixelsPerInch);			coords[2] = 72.0 * (coords[2] / hPixelsPerInch);			coords[3] = vOffsetInPoints + 72.0 * (coords[3] / vPixelsPerInch);		}				if (mode == 1) {			// Transform from IGOR coordinates into screen pixels.			coords[0] = (coords[0] / 72.0) * hPixelsPerInch;			coords[1] = ((coords[1] - vOffsetInPoints) / 72.0) * vPixelsPerInch;			coords[2] = (coords[2] / 72.0) * hPixelsPerInch;			coords[3] = ((coords[3] - vOffsetInPoints) / 72.0) * vPixelsPerInch;		}	#endif					// ]}/*	GetXOPWindowIgorPositionAndState(theWindow, coords, winStatePtr)		Returns the XOP window's position on the screen in Igor coordinates and its state.	Used with SetXOPWindowIgorPositionAndState to save and restore a window's position	and state.		Use this routine when you need to store a window position in a platform-independent	way, for example, in a /W=(left,top,right,bottom) flag. Use GetXOPWindowPositionAndState	to store a window position in a platform-dependent way, for example, in a preference file.		See TransformWindowCoordinates for a discussion of Igor coordinates. On	both Macintosh and Windows, the returned coordinates specify the location	of the window's content region, not the outside edges of the window. On Windows,	the returned coordinates specify the the location of the window in its normal state	even if the window is minmized or maximized.		On Macintosh, bit 0 of *winStatePtr is set if the window is visible and cleared	if it is hidden. All other bits are set to 0.		On Windows, bit 0 of *winStatePtr is set if the window is visible and	cleared if it is hidden. Bit 1 of *winStatePtr is set if the window is minimize	and cleared if it is not minimized. All other bits are set to 0.	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidGetXOPWindowIgorPositionAndState(XOP_WINDOW_REF windowRef, double coords[4], int* winStatePtr){	#ifdef _MACINTOSH_		Rect r;		GrafPtr thePort;		GrafPtr savePort;		thePort = GetWindowPort(windowRef);		*winStatePtr = IsWindowVisible(windowRef) ? 1:0;		GetPortBounds(thePort, &r);				// Content rectangle in local coordinates.		GetPort(&savePort);		SetPort(thePort);		LocalToGlobal((Point *)&r.top);		LocalToGlobal((Point *)&r.bottom);		SetPort(savePort);		coords[0] = r.left;		coords[1] = r.top;		coords[2] = r.right;		coords[3] = r.bottom;		TransformWindowCoordinates(0, coords);	#endif		#ifdef _WINDOWS_		WINDOWPLACEMENT wp;		RECT wr;		int frameHeight, frameWidth, captionHeight;				*winStatePtr = IsWindowVisible(windowRef) ? 1:0;		if (IsIconic(windowRef))			*winStatePtr |= 2;		wp.length = sizeof(wp);		GetWindowPlacement(windowRef, &wp);		wr = wp.rcNormalPosition;				// wr contains the outer window coordinates. We transform this into the "content area".		frameHeight = GetSystemMetrics(SM_CYFRAME);		frameWidth = GetSystemMetrics(SM_CXFRAME);		captionHeight = GetSystemMetrics(SM_CYCAPTION);		wr.left += frameWidth;		wr.right -= frameWidth;		wr.top += frameHeight + captionHeight;		wr.bottom -= frameHeight;			// Now convert to floating point and to Igor coordinates.		coords[0] = wr.left;		coords[1] = wr.top;		coords[2] = wr.right;		coords[3] = wr.bottom;		TransformWindowCoordinates(0, coords);	#endif}/*	SetXOPWindowIgorPositionAndState(theWindow, coords, winState)		Moves the XOP window to the position indicated by coords and sets its state.	Used with GetXOPWindowIgorPositionAndState to save and restore a window's position	and state.		Use this routine when you need to restore a window position in a platform-independent	way, for example, in a /W=(left,top,right,bottom) flag. Use SetXOPWindowPositionAndState	to restore a window position in a platform-dependent way, for example, in a preference file.		See GetXOPWindowIgorPositionAndState for a discussion of the units of coords	and the meaning of the winState parameter.		This routine makes an effort to prevent the window from becoming inaccessible	because it is off-screen.	This routine was added in XOP Toolkit release 3.1 but works with all supported	versions of Igor.*/voidSetXOPWindowIgorPositionAndState(XOP_WINDOW_REF windowRef, double coords[4], int winState){	#ifdef _MACINTOSH_		int left, right, top, bottom, width, height;		RgnHandle grayRgn;		Rect frameRect;		double coords2[4];				memcpy(coords2, coords, sizeof(coords2));			// To avoid modifying the input parameter.		TransformWindowCoordinates(1, coords2);				// Transform from Igor coordinates into screen coordinates.		if ((winState & 1) == 0)			HideWindow(windowRef);		left = coords2[0] + .5;								// + .5 for rounding.		right = coords2[2] + .5;		top = coords2[1] + .5;		bottom = coords2[3] + .5;		width = right - left;		height = bottom - top;				SetRect(&frameRect, left, top-20, right, top);		// Roughly the window frame rect.		InsetRect(&frameRect, 5, 5);						// Make sure at least 5 pixels of frame are on the desktop.		grayRgn = GetGrayRgn();		if (!RectInRgn(&frameRect, grayRgn)) {				// Window frame is completely out of desktop?			Rect bounds;			GetRegionBounds(grayRgn, &bounds);			left = bounds.left + 3;			top = bounds.top + 23;			right = left + width;			bottom = top + height;		}		if (width < 10)			width = 10;		if (height < 10)			height = 10;		MoveWindow(windowRef, left, top, 0);		SizeWindow(windowRef, width, height, -1);		if ((winState & 1) != 0)			ShowWindow(windowRef);	#endif		#ifdef _WINDOWS_		WINDOWPLACEMENT wp;		RECT childRECT, mdiClientRECT;		double coords2[4];		int frameHeight, frameWidth, captionHeight;				memcpy(coords2, coords, sizeof(coords2));			// To avoid modifying the input parameter.		TransformWindowCoordinates(1, coords2);				// Transform from Igor coordinates into screen coordinates.		if ((winState & 1) == 0)			ShowWindow(windowRef, SW_HIDE);				wp.length = sizeof(wp);		GetWindowPlacement(windowRef, &wp);		wp.flags = 0;		if (winState & 2) {						// Want to minimize?			wp.showCmd = SW_MINIMIZE;		}		else {			if ((winState & 1) != 0)				wp.showCmd = SW_SHOWNORMAL;			else				wp.showCmd = SW_HIDE;		}				childRECT.left = coords2[0] + .5;					// + .5 for rounding.		childRECT.right = coords2[2] + .5;		childRECT.top = coords2[1] + .5;		childRECT.bottom = coords2[3] + .5;				// childRECT contains the "content area" coordinates. We transform this into the outer window coordinates.		frameHeight = GetSystemMetrics(SM_CYFRAME);		frameWidth = GetSystemMetrics(SM_CXFRAME);		captionHeight = GetSystemMetrics(SM_CYCAPTION);		childRECT.left -= frameWidth;		childRECT.right += frameWidth;		childRECT.top -= frameHeight + captionHeight;		childRECT.bottom += frameHeight;		GetClientRect(IgorClientHWND(), &mdiClientRECT);		if (childRECT.top < 0)			OffsetRect(&childRECT, 0, -childRECT.top);		if (childRECT.top > mdiClientRECT.bottom)			OffsetRect(&childRECT, 0, -(childRECT.top - mdiClientRECT.bottom + 10));		if (childRECT.right < 0)			OffsetRect(&childRECT, -childRECT.right + 10, 0);		if (childRECT.left > mdiClientRECT.right)			OffsetRect(&childRECT, -(childRECT.left - mdiClientRECT.right + 10), 0);		wp.rcNormalPosition = childRECT;				SetWindowPlacement(windowRef, &wp);	#endif}/*	TellIgorWindowStatus(windowRef, status, options)	Call TellIgorWindowStatus when you hide or show your window, when it is activated or deactivated	and when it is about to be killed.		TellIgorWindowStatus allows your window to be included various Igor features such	as the  Recent Windows menu item and the Show Recently Hidden Windows menu item.	It is not required that you call this routine but is recommended. If you do not call	this routine then your windows will not participate in these features.		Here are the calls to make at the appropriate times:		TellIgorWindowStatus(windowRef, WINDOW_STATUS_DID_HIDE, 0);		TellIgorWindowStatus(windowRef, WINDOW_STATUS_DID_SHOW, 0);		TellIgorWindowStatus(windowRef, WINDOW_STATUS_ACTIVATED, 0);		TellIgorWindowStatus(windowRef, WINDOW_STATUS_DEACTIVATED, 0);		TellIgorWindowStatus(windowRef, WINDOW_STATUS_ABOUT_TO_KILL, 0);		NOTE: If you call this routine with any status, you must also call it when your window	is about to be killed so Igor can remove it from various internal lists. Failure to do	so may cause a crash.		Returns 0 if OK or IGOR_OBSOLETE.	Added for Igor Pro 6.0. If you call this with an earlier version of Igor,	it will return IGOR_OBSOLETE and do nothing.*/intTellIgorWindowStatus(XOP_WINDOW_REF windowRef, long status, long options){	return CallBack3(TELL_IGOR_WINDOW_STATUS, windowRef, (void*)status, (void*)options);}/*	*** Text Windows for XOPs *** *//*	TUNew(winPtr, borderRectPtr, font, size, crOnly)	NOTE: TUNew is supported on Macintosh only. Windows XOPs must use TUNew2.	New Macintosh XOPs should also use TUNew2 unless they need to run with versions	of Igor Pro earlier than 3.13.	TUNew() takes a pointer to an existing window and makes it a text window.		Returns a TU handle to the document describing the text window or NIL if memory could not be	allocated.		winPtr is a pointer to the window to make a text window	borderRectPtr is a pointer to a rectangle that defines a border around the edges of the	window in which text should not go or NIL if no special border	font is the font for the text	size is the type size for the text	crOnly is -1 if line breaks are to occur only at CRs or 0 otherwise.*/#ifdef _MACINTOSH_	// [HandleTUNew(WindowPtr winPtr, Rect *borderRectPtr, int font, int size, int crOnly){	Handle TU;		TU = (Handle)CallBack5(TUNEW,winPtr,borderRectPtr,(void*)font,(void*)size,(void*)crOnly);	return(TU);}#endif				// ]/*	TUNew2(winTitle, winRectPtr, TUPtr, windowRefPtr)	TUNew2 creates a new text window and TU document.		winTitle points to the title for the new window.		winRectPtr points to a Macintosh Rect which specifies the size and location of	the content region of the window in units of pixels.		On Macintosh, this is in global coordinates.  Use a top coordinate of 40 to position	the window right below the menu bar.		On Windows, it is in client window coordinates of the Igor MDI frame window. Use a	top coordinate of 22 to position the window right below the menu bar.		It returns via TUPtr a handle to the TU document and returns via windowRefPtr	a pointer to a WindowPtr (Mac) or HWND (Windows) for the newly created window.		In the event of an error, it returns non-zero as the function result and NULL via	TUPtr and windowRefPtr.	TUNew2 uses a default font and font size. The resulting text document is like	an Igor plain text notebook.		The window is initially hidden. Call ShowAndActivateXOPWindow to show it.		TUNew2 was added in Igor Pro 3.13.*/intTUNew2(const char* winTitle, const Rect* winRectPtr, Handle* TUPtr, XOP_WINDOW_REF* windowRefPtr){	int err;		*TUPtr = NULL;	*windowRefPtr = NULL;	err = CallBack4(TUNEW2, (void*)winTitle, (void*)winRectPtr, TUPtr, windowRefPtr);	return err;}	/*	TUDispose(TU)	TUDispose disposes of the TE record, the window, and the TU record for the specified	TU window. This should be called for any TU windows when the XOP is about to be disposed.*/void	TUDispose(TUStuffHandle TU){	CallBack1(TUDISPOSE, TU);}	/*	TUDisplaySelection(TU)	Tries to get the selected text in view as best as it can by scrolling.		The rules for vertical scrolling used by TUSelToView are:		if selStart and selEnd are in view, do nothing		if selected text won't fit in window vertically			bring selStart line to top of window		if selected text will fit vertically			if selStart line is above				bring selStart line to top			if selEnd is below				bring selEnd line to bottom		If the selected text is multiline, it won't scroll horizontally to get the right edge in	view.  This gives best intuitive results.*/voidTUDisplaySelection(TUStuffHandle TU){	CallBack1(TUDISPLAYSELECTION, TU);}/*	TUGrow(TU, size)		TUGrow() adjust the window size.	Size is the size of the window packed into a 32 bit integer.		The vertical size is in the high word and the horizontal size is in the low word.		However, if size = 0 then it does a zoom rather than a grow.		Also, if size == -1, then TUGrow does not resize the window but merely adjusts	for a change in size that has already been done. For example, TUGrow moves	the scroll bars to the new edges of the window. NOTE: This feature was	added in Igor Pro 3.13. Do not use this feature with earlier versions	of Igor.*/voidTUGrow(TUStuffHandle TU, long size){		CallBack2(TUGROW, TU, (void*)size);}/*	TUDrawWindow(TU)	Draws the window containing the text referred to by TU.*/voidTUDrawWindow(TUStuffHandle TU){		CallBack1(TUDRAWWINDOW, TU);}/*	TUUpdate(TU)	Updates the window containing the text referred to by TU if the updateRgn of the window	is not empty.*/voidTUUpdate(TUStuffHandle TU){		CallBack1(TUUPDATE, TU);}/*	TUFind(TU, code)	code:	1 = normal find			2 = find same			3 = find selection*/voidTUFind(TUStuffHandle TU, int code){		CallBack2(TUFIND, TU, (void*)code);}voidTUReplace(TUStuffHandle TU){		CallBack1(TUREPLACE, TU);}voidTUIndentLeft(TUStuffHandle TU){		CallBack1(TUINDENTLEFT, TU);}voidTUIndentRight(TUStuffHandle TU){		CallBack1(TUINDENTRIGHT, TU);}/*	TUClick(TU, eventPtr)	Services click referred to by eventPtr.*/voidTUClick(TUStuffHandle TU, EventRecord* eventPtr){		CallBack2(TUCLICK, TU, eventPtr);}voidTUActivate(TUStuffHandle TU, long flag){		CallBack2(TUACTIVATE, TU, (void*)flag);}voidTUIdle(TUStuffHandle TU){		CallBack1(TUIDLE, TU);}voidTUNull(TUStuffHandle TU, EventRecord* eventPtr){		CallBack2(TUNULL, TU, eventPtr);}voidTUCopy(TUStuffHandle TU){		CallBack1(TUCOPY, TU);}voidTUCut(TUStuffHandle TU){		CallBack1(TUCUT, TU);}voidTUPaste(TUStuffHandle TU){		CallBack1(TUPASTE, TU);}voidTUClear(TUStuffHandle TU){		CallBack1(TUCLEAR, TU);}voidTUKey(TUStuffHandle TU, EventRecord* eventPtr){		CallBack3(TUKEY, TU, (void*)(long)eventPtr->modifiers, (void*)(eventPtr->message));}voidTUInsert(TUStuffHandle TU, const char *dataPtr, long dataLen){		CallBack3(TUINSERT, TU, (void*)dataPtr, (void*)dataLen);}voidTUDelete(TUStuffHandle TU){		CallBack1(TUDELETE, TU);}voidTUSetSelect(TUStuffHandle TU, long start, long end){		CallBack3(TUSETSELECT, TU, (void*)start, (void*)end);}voidTUSelectAll(TUStuffHandle TU){		CallBack1(TUSELECTALL, TU);}voidTUUndo(TUStuffHandle TU){		CallBack1(TUUNDO, TU);}voidTUPrint(TUStuffHandle TU){		CallBack1(TUPRINT, TU);}/*	TUFixEditMenu(TU)	Sets items in edit menu properly according to the state of the TU document.*/voidTUFixEditMenu(TUStuffHandle TU){	CallBack1(TUFIXEDITMENU, TU);}/*	TUFixFileMenu(TU)	Sets items in file menu properly according to the state of the TU document.*/voidTUFixFileMenu(TUStuffHandle TU){	CallBack1(TUFIXFILEMENU, TU);}/*	TUGetText(TU)	TUGetText() returns a handle to the text in the specified document.	The handle belongs to Igor. You should not dispose it.		HR, 10/23/93:		Prior to Igor Pro 2.0, this returned the actual TextEdit handle		used for the document. Now, it returns a snapshot of the text in		the document at the time the call is made. You should not depend		on this remaining valid once you return to Igor.*/HandleTUGetText(TUStuffHandle TU){	return((Handle)CallBack1(TUGETTEXT, TU));}/*	TUFetchText(TU, offset, numChars, buffer)	Copies numChars characters from the TU document specified by TU to the specified buffer.	offset is the offset from the start of the document to the first character to fetch.		HR, 10/23/93:		This callback is obsolescent. New XOPs should use TUFetchParagraphText.*/voidTUFetchText(TUStuffHandle TU, long offset, long numChars, char *buffer){	CallBack4(TUFETCHTEXT, TU, (void*)offset, (void*)numChars, buffer);}/*	TULength(TU)	TULength() returns the number of characters in the specified document.		HR, 10/23/93:		This callback is obsolescent. New XOPs should use TUDocInfo.*/longTULength(TUStuffHandle TU){	return(CallBack1(TULENGTH, TU));}/*	TULines(TU)	TULines() returns the number of lines in the specified document.*/longTULines(TUStuffHandle TU){	return(CallBack1(TULINES, TU));}/*	TUSelStart(TU)	TUSelStart() returns the position of the start of the selection range.		HR, 10/23/93:		This callback is obsolescent. New XOPs should use TUGetSelLocs.*/longTUSelStart(TUStuffHandle TU){	return(CallBack1(TUSELSTART, TU));}/*	TUSelEnd(TU)	TUSelEnd() returns the position of the end of the selection range.		HR, 10/23/93:		This callback is obsolescent. New XOPs should use TUGetSelLocs.*/longTUSelEnd(TUStuffHandle TU){	return(CallBack1(TUSELEND, TU));}/*	TUSelectionLength(TU)	HR, 10/23/93:		This callback is obsolescent. New XOPs should use TUGetSelLocs.*/longTUSelectionLength(TUStuffHandle TU){	return(CallBack1(TUSELLENGTH, TU));}/*	TUInsertFile(TU, fileName, wdRefNum)	Inserts text from the specified file at the insertion point of the specified document.	Returns error code from insertion.*/intTUInsertFile(TUStuffHandle TU, const char *fileName, int wdRefNum){		return(CallBack3(TUINSERTFILE, TU, (void*)fileName, (void*)wdRefNum));}/*	TUWriteFile(TU, fileName, wdRefNum, allFlag)	Writes text from the specified document to specified file. Replaces file if it already exists.	allFlag = 0 means write only selected text. Otherwise, write all text.	Returns error code from write.*/intTUWriteFile(TUStuffHandle TU, const char *fileName, int wdRefNum, int allFlag){		return(CallBack4(TUWRITEFILE, TU, (void*)fileName, (void*)wdRefNum, (void*)allFlag));}/*	TUSFInsertFile(TU, prompt, fileTypes, numTypes)	Gets file from user using standard file package open dialog.	prompt is a prompt to appear in standard save dialog.	fileTypes is a pointer to an OSType array of file types.	numTypes is the number of file types in the array.		Inserts text from the file at the insertion point of the specified document.	Returns error code from insertion.*/intTUSFInsertFile(TUStuffHandle TU, const char *prompt, OSType fileTypes[], int numTypes){		return(CallBack4(TUSFINSERTFILE, TU, (void*)prompt, fileTypes, (void*)numTypes));}/*	TUSFWriteFile(TU, prompt, fileType, allFlag)	Gets file name from user using standard file package save dialog.		Writes text from the specified document to file. Replaces file if it already exists.		prompt is a prompt to appear in standard save dialog.	fileType is type of file to be written (e.g. 'TEXT').	allFlag = 0 means write only selected text. Otherwise, write all text.		Returns error code from write.*/intTUSFWriteFile(TUStuffHandle TU, const char *prompt, OSType fileType, int allFlag){		return(CallBack4(TUSFWRITEFILE, TU, (void*)prompt, (void*)fileType, (void*)allFlag));}voidTUPageSetupDialog(TUStuffHandle TU){	CallBack1(TUPAGESETUPDIALOG, TU);}/*	TUGetDocInfo(TU, dip)		Returns information about the text utility document via the structure pointed to by dip.	You MUST execute		dip->version = TUDOCINFO_VERSION	before calling TUGetDocInfo so that Igor knows which version of the structure	your XOP is using.		Returns 0 if OK, -1 if unsupported version of the structure or an Igor error	code if the version of Igor that is running does not support this callback.	Added for Igor Pro 2.0D83.*/intTUGetDocInfo(TUStuffHandle TU, TUDocInfoPtr dip){	return CallBack2(TUGETDOCINFO, TU, dip);}/*	TUGetSelLocs(TU, startLocPtr, endLocPtr)	Sets *startLocPtr and *endLocPtr to describe the selected text in the document.	Returns 0 if OK, an Igor error code if the version of Igor that you are running	with does not support this callback.		Added for Igor Pro 2.0D83.*/intTUGetSelLocs(TUStuffHandle TU, TULocPtr startLocPtr, TULocPtr endLocPtr){	return CallBack3(TUGETSELLOCS, TU, startLocPtr, endLocPtr);}/*	TUSetSelLocs(TU, startLocPtr, endLocPtr, flags)	If startLocPtr is not NIL, sets the selection in the text utility document	based on startLocPtr and endLocPtr which must be valid.		If flags is 1, displays the selection if it is out of view.	Other bits in flags may be used for other purposes in the future.	Returns 0 if OK, an Igor error code if the version of Igor that you are running	with does not support this callback. Also returns an error if the start or	end locations are out of bounds or if the start location is after the end location.		Added for Igor Pro 2.0D83.*/intTUSetSelLocs(TUStuffHandle TU, TULocPtr startLocPtr, TULocPtr endLocPtr, long flags){	return CallBack4(TUSETSELLOCS, TU, startLocPtr, endLocPtr, (void*)flags);}/*	TUFetchParagraphText(TU, paragraph, textPtrPtr, lengthPtr)		If textPtrPtr is not NIL, returns via textPtrPtr the text in	the specified paragraph.	Sets *lengthPtr to the number of characters in the paragraph	whether textPtrPtr is NIL or not.		paragraph is assumed to be a valid paragraph number.	textPtrPtr is a pointer to your char* variable.	Igor allocates a pointer, using NewPtr, and sets *textPtrPtr to	point to the allocated memory.		Example:		char* p;		long paragraph, length;		int result;				paragraph = 0;		if (result = TUFetchParagraphText(TU, paragraph, &p, &length))			return result;				<Deal with the text>				DisposePtr(p);		Note that the text pointed to by p is NOT null terminated and therefore	is not a C string. You can turn it into a C string as follows:		SetPtrSize(p, length+1);		if (result = MemError()) {			DisposePtr(p);			return result		}		p[length] = 0;	Returns 0 if OK, an Igor error code if an error occurs fetching the text	or the version of Igor that you are running with does not support this callback.	Also returns an error if the paragraph is out of bounds.		Added for Igor Pro 2.0D83.*/intTUFetchParagraphText(TUStuffHandle TU, long paragraph, Ptr *textPtrPtr, long *lengthPtr){	return CallBack4(TUFETCHPARAGRAPHTEXT, TU, (void*)paragraph, textPtrPtr, lengthPtr);}/*	TUFetchSelectedText(TU, textHandlePtr, reservedForFuture, flags)		Returns via textHandlePtr the selected text in the text utility document.		textHandlePtr is a pointer to your Handle variable.	reservedForFuture should be NIL for now.	flags should be 0 for now.		Example:		Handle h;		int result;				paragraph = 0;		if (result = TUFetchSelectedText(TU, &h, NIL, 0))			return result;				<Deal with the text>				DisposeHandle(h);		Note that the text in the handle h is NOT null terminated and therefore	is not a C string. You can turn it into a C string as follows:		length = GetHandleSize(h);		SetHandleSize(h, length+1);		if (result = MemError()) {			DisposeHandle(h);			return result		}		*h[length] = 0;	Returns 0 if OK, an Igor error code if an error occurs fetching the text	or the version of Igor that you are running with does not support this callback.		Added for Igor Pro 2.0D83.*/intTUFetchSelectedText(TUStuffHandle TU, Handle* textHandlePtr, void* reservedForFuture, long flags){	return CallBack4(TUFETCHSELECTEDTEXT, TU, textHandlePtr,  reservedForFuture, (void*)flags);}/*	TUSetStatusArea(TU, message, eraseFlags, statusAreaWidth)	If message is not NIL, sets the status message in the text utility document.	message is a C string. Only the first 127 characters are displayed.		If message is not NIL then eraseFlags determines when the status	message will be erased. See the TU_ERASE_STATUS #defines in IgorXOP.h.		If statusAreaWidth is >= 0, sets the width of the status area.	This is in pixels.	Returns 0 if OK, an Igor error code if the version of Igor that you are running	with does not support this callback.		Added for Igor Pro 2.0D83.*/intTUSetStatusArea(TUStuffHandle TU, const char* message, int eraseFlags, int statusAreaWidth){	return CallBack4(TUSETSTATUSAREA, TU, (void*)message,  (void*)eraseFlags, (void*)statusAreaWidth);}/*	TUMoveToPreferredPosition(TUStuffHandle TU)	Moves the window to the preferred position, as determined by the user's notebook	preferences. Normally, you will call this in response to the MOVE_TO_PREFERRED_POSITION	message from IGOR.		During the TUMoveToPreferredPosition call, your XOP will receive a GROW message from IGOR.	On Windows, your window procedure may also receive several messages from the operating system.		Added for Igor Pro 3.10B03. Does nothing in earlier versions of Igor.*/voidTUMoveToPreferredPosition(TUStuffHandle TU){	CallBack1(TUMOVE_TO_PREFERRED_POSITION, TU);}/*	TUMoveToFullSizePosition(TUStuffHandle TU)	Moves the window to show all of its content or to fill the screen (Macintosh) or	MDI frame window (Windows). Normally, you will call this in response to the	MOVE_TO_FULLSIZE_POSITION message from IGOR.		During the TUMoveToFullSizePosition call, your XOP will receive a GROW message from IGOR.	On Windows, your window procedure may also receive several messages from the operating system.		Added for Igor Pro 3.10B03. Does nothing in earlier versions of Igor.*/voidTUMoveToFullSizePosition(TUStuffHandle TU){	CallBack1(TUMOVE_TO_FULL_POSITION, TU);}/*	TURetrieveWindow(TUStuffHandle TU)	Moves the window, if necessary, to fit entirely within the screen (Macintosh) or	MDI frame window (Windows). Normally, you will call this in response to the	RETRIEVE message from IGOR.		During the TURetrieveWindow call, your XOP will receive a GROW message from IGOR.	On Windows, your window procedure may also receive several messages from the operating system.		Added for Igor Pro 3.10B03. Does nothing in earlier versions of Igor.*/voidTURetrieveWindow(TUStuffHandle TU){	CallBack1(TURETRIEVE, TU);}#include "XOPStructureAlignmentReset.h"	// Reset structure alignment to default.