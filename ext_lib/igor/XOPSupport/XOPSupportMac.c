/*	This file contains routines that are Macintosh-specific.	This file is used only when compiling for Macintosh.*/#include "XOPStandardHeaders.h"			// Include ANSI headers, Mac headers, IgorXOP.h, XOP.h and XOPSupport.h#include "XOPStructureAlignmentTwoByte.h"	// All structures passed between Igor and XOP are two-byte aligned.intIsMacOSX(void)		// Returns true if we are running under Mac OS X.{	long gval;		static int isMacOSX = -1;					// -1 means this variable has not yet been initialized.		if (isMacOSX >= 0)		return isMacOSX;	isMacOSX = 0;	Gestalt(gestaltMenuMgrAttr, &gval);	if (gval & gestaltMenuMgrAquaLayoutMask)	// This is the method suggested in the Carbon Porting Guide.		isMacOSX = 1;		return isMacOSX;}voiddebugstr(const char* message)			// Sends debug message to low level debugger (e.g., Macsbug).{	char ctemp[256];	unsigned char ptemp[256];	int len;		len = strlen(message);	if (len >= sizeof(ctemp))		len = sizeof(ctemp)-1;	strncpy(ctemp, message, len);	ctemp[len] = 0;	CopyCStringToPascal(ctemp, ptemp);	DebugStr(ptemp);}voidparamtext(const char* param0, const char* param1, const char* param2, const char* param3){	unsigned char p0[256];	unsigned char p1[256];	unsigned char p2[256];	unsigned char p3[256];	CopyCStringToPascal(param0, p0);	CopyCStringToPascal(param1, p1);	CopyCStringToPascal(param2, p2);	CopyCStringToPascal(param3, p3);	ParamText(p0, p1, p2, p3);}/*	File-system Routines	These are utilities for using the Macintosh File Manager.	There are no Windows equivalent routines, so these routines can't be used in	Windows or cross-platform XOPs.*/static unsigned char *pStrcat(unsigned char *dest, unsigned char *src)		// From Apple tech note #238.{	long sLen;		sLen = *src;	if (sLen > 255 - *dest)		sLen = 255 - *dest;		memmove(dest+*dest+1, src+1, sLen);	*dest += sLen;	return(dest);}static unsigned char *pStrcpy(unsigned char *dest, unsigned char *src)		// From Apple tech note #238.{	memmove(dest, src, (long)*src+1);	return(dest);}/*	GetFullMacPathToDirectory(vRefNum, dirID, pathOut, maxPathLen)	Based on Apple tech note #238.	This routine is provided only for the benefit of existing Macintosh XOPs. New	XOPs use platform-independent techniques and don't require this routine.  	Stores in pathOut a full path to the folder specified by vRefNum	and dirID.	vRefNum is either a volume reference number or a working directory	reference number.		dirID must be a directory ID if vRefNum is a volume reference number.	dirID must be zero if vRefNum is a working directory reference number.		pathOut must be able to hold maxPathLen characters PLUS the terminating null character.		Returns 0 if OK or an error code.		Prior to Carbon, this routine accepted wither a volume reference number and directory	ID or a working directory reference number and zero. Carbon does not support	working directory reference numbers, so this routine now supports only	a volume reference number and directory ID.*/intGetFullMacPathToDirectory(long vRefNum, long dirID, char* pathOut, int maxPathLen){	CInfoPBRec block;	char directoryName[256];	int err;		*pathOut=0;	block.dirInfo.ioNamePtr = (unsigned char*)directoryName;	block.dirInfo.ioDrParID = dirID;	do {		block.dirInfo.ioVRefNum = vRefNum;		block.dirInfo.ioFDirIndex = -1;		block.dirInfo.ioDrDirID = block.dirInfo.ioDrParID;				err = PBGetCatInfoSync(&block);		pStrcat((unsigned char*)directoryName, (unsigned char *)"\p:");		if (*directoryName + *pathOut > maxPathLen)	/* Pascal strings */			return(1);								/* error, string too long */		pStrcat((unsigned char*)directoryName, (unsigned char*)pathOut);		pStrcpy((unsigned char*)pathOut, (unsigned char*)directoryName);	} while (block.dirInfo.ioDrDirID != fsRtDirID);	CopyPascalStringToC((unsigned char *)pathOut, pathOut);	return(0);}/*	Resource Routines -- for dealing with resources	These routines are for accessing Macintosh resource forks.	There are no Windows equivalent routines, so these routines can't be used in	Windows or cross-platform XOPs.*//*	XOPRefNum()	Returns XOP's resource file reference number.*/intXOPRefNum(void){	return((*(*XOPRecHandle)->stuffHandle)->newApRefNum);}/*	GetXOPResource(resType, resID)	Tries to get specified handle from XOP's resource fork.	Does not search any other resource forks and does not change curResFile.*/HandleGetXOPResource(long resType, int resID){	Handle rHandle;	int curResNum;		curResNum = CurResFile();	UseResFile(XOPRefNum());	rHandle = Get1Resource(resType, resID);	UseResFile(curResNum);	return(rHandle);}/*	GetXOPNamedResource(resType, name)	Tries to get specified handle from XOP's resource fork.	Does not search any other resource forks and does not change curResFile.*/HandleGetXOPNamedResource(long resType, char *name){	Handle rHandle;	unsigned char pName[256];	int curResNum;		curResNum = CurResFile();	UseResFile(XOPRefNum());	CopyCStringToPascal(name, pName);	rHandle = Get1NamedResource(resType, pName);	UseResFile(curResNum);	return rHandle;}/*	Dialog Routines	These are Macintosh dialog routines that have no Windows equivalent.*/static voidShowHideContextualHelp(int code)		// -1 means toggle, 0 means hide, 1 means show contextual help window.{	CallBack1(SHOW_HIDE_CONTEXTUAL_HELP, (void*)code);}/*	XOPGetDialogItemAsControl(theDialog, itemNumber, controlHPtr)	Returns via controlHPtr the control handle for the specified dialog item.		This routine displays an error message in Igor's history area if the	item in question does not have an associated control handle. This would be	a programming bug that the XOP programmer must correct.		Long ago, the Mac OS provided a set of Dialog Manager calls that you could call	to manipulate dialog items. Then Apple introduced new capabilities implemented	by a part of the OS called the Appearance Manager. The method for manipulating	a dialog item (e.g., setting the text of an EditText field) depends on whether	you use Appearance Manager features or not. All modern code uses Appearance	Manager techniques.		To avoid the need to support two ways of doing the same thing, the Carbon XOP	Toolkit dialog support routines ASSUME that the dialog is Appearance-Manager savvy.	You make your dialog Appearance savvy by:		1. Including a dlgx resource with the same resource ID as your DLOG resource.	2. Including the kDialogFlagsUseControlHierarchy bit in the dlgx resource.	3. Using Appearance Manager programming methods for implementing your dialog.		Including the kDialogFlagsUseControlHierarchy bit in the dlgx resource causes	the Mac OS to create a control handle for each item in your dialog, if the item	is not already defined as a CNTL item.		If this routine prints an error message for a valid dialog item number,	this indicates that you have not made your dialog resources and/or code	Appearance-Manager savvy.*/intXOPGetDialogItemAsControl(DialogPtr theDialog, int itemNumber, ControlHandle* controlHPtr){	int err;		err = GetDialogItemAsControl(theDialog, itemNumber, controlHPtr);	if (err==0 && *controlHPtr==NULL)			// Should never happen.		err = -1;	if (err) {		char message[256];		sprintf(message, "XOP Bug: XOPGetDialogItemAsControl got error %d for item number %d."CR_STR, err, itemNumber);		XOPNotice(message);	}	return err;}/*	XOPDialogFilter(dialog, eventPtr, itemHitPtr)		Handles the mapping of the enter key to the default button, the mapping	of the escape key to the cancel button, and setting the cursor depending on	the control under it. This requires that you previously called SetDialogDefaultItem,	SetDialogCancelItem and SetDialogTracksCursor as shown in the sample XOPs.		Also handles updating Igor windows if the dialog is moved. However, it does not	update XOP windows.*/static pascal BooleanXOPDialogFilter(DialogPtr theDialog, EventRecord *eventPtr, short *itemHitPtr){	int callStdFilter;	int result;    result = 0;					// Means ModalDialog should handle the event.    callStdFilter = 1;        switch (eventPtr->what) {    	case updateEvt:    		if ((WindowPtr)eventPtr->message != GetDialogWindow(theDialog)) {				if (!IsMacOSX())	// Mac OS X does the updating automatically, apparently using offscreen bitmaps.    				DoUpdate();		// Make Igor update its windows.    		}    		break;    	    	case keyDown:    		{    			int keyCode = eventPtr->message & charCodeMask;		// Low order byte is character code.    			switch(keyCode) {    				case kHelpCharCode:    					if (eventPtr->modifiers & optionKey) {    						// option-help shows or hides Igor's contextual help window.    						ShowHideContextualHelp(-1);    						result = -1;							// We handled the event.    						*itemHitPtr = 0;						// This is not a hit in any item.    						callStdFilter = 0;    					}    					break;    			}    		}    		break;    }        if (callStdFilter)		result = StdFilterProc(theDialog, eventPtr, itemHitPtr);		return result;}static ModalFilterUPP gXOPDialogFilterUPP = NULL;	// Created by GetXOPDialog, disposed by DisposeXOPDialog./*	GetXOPDialog(dialogID)	This routine is implemented on Macintosh only.*/DialogPtrGetXOPDialog(int dialogID){	DialogPtr theDialog;	int saveResFile;		saveResFile = CurResFile();	UseResFile(XOPRefNum());	theDialog = GetNewDialog(dialogID, NIL, (WindowPtr)-1);	UseResFile(saveResFile);	if (theDialog == NULL)		return NULL;	gXOPDialogFilterUPP = NewModalFilterUPP(XOPDialogFilter);		return theDialog;}/*	DisposeXOPDialog(dialogID)	This routine is implemented on Macintosh only.*/voidDisposeXOPDialog(DialogPtr theDialog){	DisposeDialog(theDialog);	if (gXOPDialogFilterUPP != NULL) {		DisposeModalFilterUPP(gXOPDialogFilterUPP);		gXOPDialogFilterUPP = NULL;	}		SetDialogBalloonHelpID(-1);		// Tell Igor's contextual help that the dialog is finished.}/*	XOPDialog(filterProc, itemPtr)	This routine merely calls the Mac toolbox ModalDialog routine. In the days	of 68K Macintoshes, it did some additional work that is no longer needed.		NOTE:	If you are compiling a PowerMac native XOP, the filterProc parameter			must be the address of a routine descriptor or NIL, not the direct address			of your filter routine.	This routine is implemented on Macintosh only.*/voidXOPDialog(ModalFilterUPP filterProc, short *itemPtr){	ModalDialog(filterProc, itemPtr);}/*	DoXOPDialog(itemHitPtr)	This routine is implemented on Macintosh only.*/voidDoXOPDialog(short* itemHitPtr){	XOPDialog(gXOPDialogFilterUPP, itemHitPtr);}// Open and Save File Support Routines// Structure used during the filtering of files.struct XOPNavFileTypeInfo {	char menuItemText[256];	char fileTypes[256];			// e.g., "TEXT,IGTX,****"	char extensions[256];			// e.g., ".txt,.itx"};typedef struct XOPNavFileTypeInfo XOPNavFileTypeInfo;typedef struct XOPNavFileTypeInfo* XOPNavFileTypeInfoPtr;typedef struct XOPNavFileTypeInfo** XOPNavFileTypeInfoHandle;/*	XOPNavGetMenuItemSpecsHandle(XOPNavFileTypeInfoHandle ftiH, int numMenuItems)		Creates and returns a NavMenuItemSpecArrayHandle which is passed to	Mac Navigation Services to create the custom menu items.		Returns NULL if error.*/static NavMenuItemSpecArrayHandleXOPNavGetMenuItemSpecsHandle(XOPNavFileTypeInfoHandle ftiH, int numMenuItems){	NavMenuItemSpecArrayHandle menuItemSpecsH;	long numBytes;	int i;		numBytes = numMenuItems*sizeof(NavMenuItemSpec);	menuItemSpecsH = (NavMenuItemSpecArrayHandle)NewHandle(numBytes);	if (menuItemSpecsH == NULL)		return NULL;	MemClear(*menuItemSpecsH, numBytes);	for(i=0; i<numMenuItems; i+=1) {		char menuItemText[256];				(*menuItemSpecsH)[i].version = kNavMenuItemSpecVersion;		(*menuItemSpecsH)[i].menuCreator = kNavGenericSignature;		(*menuItemSpecsH)[i].menuType = i;		// This is an index into menuItemSpecsH and ftiH.		(*menuItemSpecsH)[i].menuType += 20;	// Because Apple reserves codes below 10 for itself as of Navigation Services 2.0.		strcpy(menuItemText, (*ftiH)[i].menuItemText);		CopyCStringToPascal(menuItemText, (*menuItemSpecsH)[i].menuItemName);	}		return menuItemSpecsH;}/*	XOPNavParseFileFilterString(fileFilterStr, ftiHPtr)		Parses the fileFilterStr into a form more easily used by the file filter function.			If the fileFilterStr can be parsed correctly, XOPNavParseFileFilterString	returns a newly created XOPNavFileTypeInfoHandle via ftiHPtr	and returns a function result of 0. You must dispose of the handle	when you are finished with it.		If there is an error in parsing, no handle is returned and the function	result is non-zero.*/static intXOPNavParseFileFilterString(const char* fileFilterStr, XOPNavFileTypeInfoHandle* ftiHPtr){	XOPNavFileTypeInfoHandle ftiH;	XOPNavFileTypeInfo fti;	const char* p;	const char* p1;		*ftiHPtr = NULL;		ftiH = (XOPNavFileTypeInfoHandle)NewHandle(0L);		p = fileFilterStr;	while(*p != 0) {		MemClear(&fti, sizeof(fti));				// First get the menu item text.				p1 = strchr(p, ':');		if (p1 == NULL) {			DisposeHandle((Handle)ftiH);			return 1;						// Error - no colon to mark end of menu string.		}				if (p1 - p >= sizeof(fti.menuItemText)) {			DisposeHandle((Handle)ftiH);			return 2;						// Error - no colon to mark end of menu string.		}					strncpy(fti.menuItemText, p, p1-p);		p = p1 + 1;							// Skip past menu string to file type.			// Now get the file types associated with this menu item.				p1 = strchr(p, ':');		if (p1 == NULL) {			DisposeHandle((Handle)ftiH);			return 3;						// Error - no colon to mark end of file types.		}				if (p1 - p >= sizeof(fti.fileTypes)) {			DisposeHandle((Handle)ftiH);			return 4;						// Error - file types string too long.		}				strncpy(fti.fileTypes, p, p1-p);		p = p1 + 1;							// Skip past file types to extensions.		// Now get the extensions associated with this menu item.						p1 = strchr(p, ';');		if (p1 == NULL) {			DisposeHandle((Handle)ftiH);			return 5;						// Error - no semicolon to mark end of extensions.		}				if (p1 - p >= sizeof(fti.extensions)) {			DisposeHandle((Handle)ftiH);			return 6;						// Error - extensions string too long.		}				strncpy(fti.extensions, p, p1-p);		p = p1 + 1;							// Skip past extensions to next menu item, if any.				// Add the XOPNavFileTypeInfo record to the handle.		{			long origNumBytes = GetHandleSize((Handle)ftiH);			SetHandleSize((Handle)ftiH, origNumBytes + sizeof(XOPNavFileTypeInfo));			if (MemError()) {				DisposeHandle((Handle)ftiH);				return 7;			}			memcpy((char*)*ftiH + origNumBytes, &fti, sizeof(XOPNavFileTypeInfo));		}	}		*ftiHPtr = ftiH;		return 0;}struct XOPNavCallbackData {		// Data that is passed by Navigation Services to our filter and event functions.	int gotNavStartMessage;						// Used to workaround a bug in Navigation Service in Mac OS X.	int isOpen;									// True if Open File dialog.	int isSave;									// True if Save File dialog.	XOPNavFileTypeInfoHandle ftiH;				// Used during filtering of files. Can be NULL.		NavMenuItemSpecArrayHandle menuItemSpecsH;	// Description of our custom menu items. Can be NULL.	int index;									// Index into ftiH and menuItemSpecsH to the selected type.};typedef struct XOPNavCallbackData XOPNavCallbackData;typedef struct XOPNavCallbackData* XOPNavCallbackDataPtr;static intXOPNavFileDoFilter(XOPNavCallbackDataPtr callbackDataPtr, OSType theType, const char* theName){	XOPNavFileTypeInfoHandle ftiH;	XOPNavFileTypeInfoPtr ftiP;	int index, numMenuItems;	const char* fp;					// Pointer to file types.	const char* ep;					// Pointer to extensions.	const char* p;		ftiH = callbackDataPtr->ftiH;	if (ftiH == NULL)		return 1;		index = callbackDataPtr->index;				// Zero-based index of currently-selected menu item.	numMenuItems = GetHandleSize((Handle)ftiH) / sizeof(XOPNavFileTypeInfo);	if (index<0 || index>=numMenuItems)		return 1;								// Something is wrong.	ftiP = &(*ftiH)[callbackDataPtr->index];	// DEREFERENCE	fp = ftiP->fileTypes;						// DEREFERENCE. Points to something like "TEXT,DATA"	ep = ftiP->extensions;						// DEREFERENCE. Points to something like ".txt,.dat,.csv"		// See if this file type passes the file type test.	p = fp;	while(*p) {									// Look through list of file types for one that matches this file's type.		OSType thisType;		int i;				for(i=0; i<4; i++) {					// Check file type.			if (p[i] == 0)				return 1;						// Bad file type, contains NULL character.		}				thisType = *(OSType*)p;				if (thisType == '****')			return 1;							// '****' matches any file type.				if (thisType == theType)			return 1;							// This is the type we're looking for.					p += 4;									// Skip this file type.					if (*p != ',')			break;								// No more file types.		p += 1;									// Skip comma and continue.	}		// See if this file name passes the extension test.		{		int theNameLen;		char theExtension[64];					// Extension from this file's name.		int theExtensionLen;				p = strrchr(theName, '.');				// Find last dot.		if (p == NULL)			return 0;							// File has no extension so there can be no match.				theNameLen = strlen(theName);				theExtensionLen = theName + theNameLen - p;		if (theExtensionLen >= sizeof(theExtension))			return 0;							// File has an outlandish extension.				strncpy(theExtension, p, theExtensionLen);		theExtension[theExtensionLen] = 0;			p = ep;		while(*p) {									// Look through list of file extensions for one that matches this file's extension.			char thisExtension[64];			int thisExtensionLen;			const char* p1;						p1 = strchr(p, ',');					// Point to separator between extensions.			if (p1 == NULL)				p1 = p + strlen(p);					// Point to null after last extension.						thisExtensionLen = p1 - p;			if (thisExtensionLen >= sizeof(thisExtension))				return 0;							// Outlandish filter string.						if (thisExtensionLen == theExtensionLen) {				strncpy(thisExtension, p, thisExtensionLen);				thisExtension[thisExtensionLen] = 0;								if (CmpStr(thisExtension, theExtension) == 0)					return 1;						// Extensions match.			}						if (*p1 == 0)				break;								// End of extensions.							p = p1 + 1;								// Skip comma and continue.		}	}		return 0;			// Failed all tests.}static pascal BooleanXOPNavFileFilter(	AEDesc* theItem,	void* info,	NavCallBackUserData callBackUD,	NavFilterModes filterMode){	int display;	NavFileOrFolderInfo* theInfo;	XOPNavCallbackDataPtr callbackDataPtr;		callbackDataPtr = (XOPNavCallbackDataPtr)callBackUD;	display = 1;		theInfo = (NavFileOrFolderInfo*)info;	if (theItem->descriptorType == typeFSS) {		if (!theInfo->isFolder) {			FSSpec spec;			char theName[256];			OSType theType;			int err;			*theName = 0;			err = AEGetDescData(theItem, &spec, sizeof(FSSpec));			if (err == 0)				CopyPascalStringToC(spec.name, theName);							theType = theInfo->fileAndFolder.fileInfo.finderInfo.fdType;			display = XOPNavFileDoFilter(callbackDataPtr, theType, theName);		}	}		return display;}static pascal voidXOPNavFileEventProc(	const NavEventCallbackMessage callBackSelector, 	NavCBRecPtr callBackParms, 	NavCallBackUserData callBackUD){	XOPNavCallbackDataPtr callbackDataPtr;		callbackDataPtr = (XOPNavCallbackDataPtr)callBackUD;	switch(callBackSelector) {		case kNavCBStart:			{	// Set the initial item in the Show popup menu.				NavMenuItemSpecArrayHandle menuItemSpecsH;				int index, numMenuItemSpecs;				menuItemSpecsH = callbackDataPtr->menuItemSpecsH;				index = callbackDataPtr->index;				if (menuItemSpecsH != NULL) {					numMenuItemSpecs = GetHandleSize((Handle)menuItemSpecsH) / sizeof(NavMenuItemSpec);					if (index>=0 && index<numMenuItemSpecs) {		// Sanity check.						NavMenuItemSpec menuItemSpec;						menuItemSpec = (*menuItemSpecsH)[index];						NavCustomControl(callBackParms->context, kNavCtlSelectCustomType, &menuItemSpec);					}				}				callbackDataPtr->gotNavStartMessage = 1;			}			break;					case kNavCBEvent:			switch (callBackParms->eventData.eventDataParms.event->what) {				case updateEvt:					if (!IsMacOSX())	// Mac OS X does the updating automatically, apparently using offscreen bitmaps.						DoUpdate();		// Call back to Igor to do update.					break;			}			break;					case kNavCBPopupMenuSelect:		// User made selection in Show popup menu.			if (callbackDataPtr->gotNavStartMessage) {		// In Mac OS X, we received this message before the dialog appears. This is a Mac OS X bug.				NavMenuItemSpecPtr msp;								// Remember the index into the array of NavMenuItemSpecs.				msp = (NavMenuItemSpecPtr)callBackParms->eventData.eventDataParms.param;				callbackDataPtr->index = msp->menuType;		// index is an index into our ftiH and menuItemSpecsH handles.				callbackDataPtr->index -= 20;				// Because Apple reserves codes below 10 for itself as of Navigation Services 2.0.			}			break;	}}/*	XOPNavOpenFileDialog(prompt, fileFilterStr, fileIndexPtr, initialDirSpec, fileSpec)	This routine should not be called directly by an XOP. Instead, use the	platform-independent XOPOpenFileDialog routine.		The fileFilterString controls what appears in the Show popup menu of the	Macintosh Navigation Services Open File dialog. If you pass "", all files	will be displayed in the Open File dialog. Otherwise, the files displayed	will be controlled by the Show popup menu and the items in the Show popup	menu will be defined by the fileFilterString.		For example, if you want to let the user open text data files, you might	design the fileFilterString such that the Show popup menu contains two items,	like this:		Data Files		All Files			By providing an All Files item, you give the user a chance to open a file	that does not have the correct Macintosh file type. For example, a text file	transfered from a PC to a Macintosh might have the file type "????" rather than	"TEXT".		To obtain a Show popup menu like this, you need to supply a fileFilterString	with two sections. It might look like this:			"Data Files:TEXT,DATA:.txt,.dat,.csv;All Files:****:;"			The two section sections of this fileFilterString are:		"Data Files:TEXT,DATA:.txt,.dat,.csv;"		"All Files:****:;"			Each section causes the creation of one item in the Show popup menu.		Each section consists of three components: a menu item string to be displayed	in the Show popup menu, a list of zero or more Macintosh file types (e.g., TEXT,DATA),	and a list of extensions (e.g., .txt,.dat,.csv).		In this example, the first menu item would be "Data Files". When the user selects	this menu item, the Open File dialog would show any file whose Macintosh file type	is TEXT or DATA plus any file whose extension is .txt, .dat, or .csv.		Note that a colon marks the end of the menu item string, another colon marks the	end of the list of Macintosh file types, and a semicolon marks the end of the	list of extensions.		The **** file type used in the second section is special. It means that the	Open File dialog should display all files. In this section, no extensions	are specified because there are no characters between the colon and the	semicolon.		The syntax of the fileFilterString is unforgiving. You must not use any	extraneous spaces or any other extraneous characters. You must include the	colons and semicolons as shown above. The trailing semicolon is required.	If there is a syntax error, the entire fileFilterString will be treated	as if it were empty, which will display all files.*/intXOPNavOpenFileDialog(	const char* prompt,	const char* fileFilterStr,	int* fileIndexPtr,					// NULL or one-based index into typeList.	FSSpec* initialDirSpec,				// If not NULL, points to directory to display initially.	FSSpec* fileSpec)					// Output.{	NavReplyRecord theReply;	NavDialogOptions dialogOptions;	NavTypeListHandle openListH;	AEDesc defaultLocation;	AEDesc* defaultLocationPtr;	XOPNavCallbackData callbackData;	XOPNavFileTypeInfoHandle ftiH;	int numMenuItems;	int err;	NavEventUPP eventUPP = NewNavEventUPP(XOPNavFileEventProc);	NavObjectFilterUPP filterUPP = NewNavObjectFilterUPP(XOPNavFileFilter);	NavMenuItemSpecArrayHandle menuItemSpecsH;		MemClear(fileSpec, sizeof(FSSpec));	// Set default behavior for browser and dialog.	NavGetDefaultDialogOptions(&dialogOptions);	dialogOptions.dialogOptionFlags |= kNavDontAddTranslateItems;	dialogOptions.dialogOptionFlags |= kNavDontAutoTranslate;	dialogOptions.dialogOptionFlags |= kNavSelectAllReadableItem;	// We don't care what application created the file.	dialogOptions.preferenceKey = 0;	// CopyCStringToPascal("XOP Name", dialogOptions.clientName);	// Ideally, we would store the XOP name here, but we don't know it.	CopyCStringToPascal(prompt, dialogOptions.message);		// Prepare structure that is passed by Navigation Services to our filter and event functions.	MemClear(&callbackData, sizeof(callbackData));	callbackData.isOpen = 1;		// Parse filter strings, if any. This defines Show menu items.	ftiH = NULL;	numMenuItems = 0;	if (*fileFilterStr != 0) {								// Not empty fileFilterStr?		XOPNavParseFileFilterString(fileFilterStr, &ftiH);	// ftiH will be NULL if fileFilterStr is not correctly formed.		if (ftiH != NULL)			numMenuItems = GetHandleSize((Handle)ftiH) / sizeof(XOPNavFileTypeInfo);	}	callbackData.ftiH = ftiH;		// If we are adding custom items to the Show menu, create structure to pass to Navigation services.	menuItemSpecsH = NULL;	if (numMenuItems>0 && ftiH!=NULL) {				// We want do filter files?		menuItemSpecsH = XOPNavGetMenuItemSpecsHandle(ftiH, numMenuItems);		dialogOptions.popupExtension = menuItemSpecsH;				/*	This is what will be initially selected in the Show popup menu.			By setting these fields, we make our filter function aware of that fact.		*/		if (fileIndexPtr != NULL) {						// If fileIndexPtr not null, honor the caller's request.			if (*fileIndexPtr > 0) {					// *fileIndexPtr is one-based.				if (*fileIndexPtr <= numMenuItems)					callbackData.index = *fileIndexPtr-1;			}		}	}	callbackData.menuItemSpecsH = menuItemSpecsH;			// Can be NULL. If so, Navigation Services will display all files.		openListH = NULL;			// NavGetFile will not do file filtering or add items to the Show popup menu. We are in control.		// If we want to point the dialog to a particular initial folder, create the necessary structure.	defaultLocationPtr = NULL;	if (initialDirSpec != NULL) {		err = AECreateDesc(typeFSS, initialDirSpec, sizeof(FSSpec), &defaultLocation);		if (err == 0)			defaultLocationPtr = &defaultLocation;	}		err = NavGetFile(defaultLocationPtr, &theReply, &dialogOptions, eventUPP, NULL, filterUPP, openListH, &callbackData);	// Let the caller know which custom menu item was chosen.	if (fileIndexPtr != NULL)		*fileIndexPtr = callbackData.index+1;	// *fileIndexPtr is one-based.		if (eventUPP != NULL)		DisposeNavEventUPP(eventUPP);	if (filterUPP != NULL)		DisposeNavObjectFilterUPP(filterUPP);	if (menuItemSpecsH != NULL)		DisposeHandle((Handle)menuItemSpecsH);	if (ftiH != NULL)		DisposeHandle((Handle)ftiH);	if (defaultLocationPtr)		AEDisposeDesc(defaultLocationPtr);	if (openListH != NULL)		DisposeHandle((Handle)openListH);		if (err == userCanceledErr)		return -1;	if (err != 0)		return err;	if (!theReply.validRecord)		return -1;							// Should not happen.			// Get FSSpec from Navigation Services reply record.	{		AEKeyword keyWord;		DescType typeCode;		Size actualSize;				err = AEGetNthPtr(&theReply.selection, 1, typeFSS, &keyWord, &typeCode, fileSpec, sizeof(FSSpec), &actualSize);	}	NavDisposeReply(&theReply);		return err;}/*	XOPNavSaveFileDialog(prompt, formatMenuStr, fileIndexPtr, proposedFileName, initialDirSpec, fileSpec)	This routine should not be called directly by an XOP. Instead, use the	platform-independent XOPSaveFileDialog routine.		The formatMenuStr controls what appears in the Format popup menu of the	Macintosh Navigation Services Save File dialog. If you pass "", the Format	menu will be hidden. This is appropriate if the file can be saved in one format	only. Otherwise, the Format popup menu will be displayed and its items will	be defined by formatMenuStr.		For example, if you want to let the user save a file as either plain text or	as an Igor text file, you would use the following for formatMenuStr:		"Plain Text:TEXT:.txt;Igor Text:IGTX:.itx;"			This would give you a Format menu like this:		Plain Text		Igor Text		The format of formatMenuStr is the same as the format of the fileFilterStr	parameter to XOPNavOpenFileDialog, except that you should specify only one	file type and extension for each section.		At present, only the menu item strings ("Plain Text" and "Igor Text"	in the example above) are used. The Macintosh file types (TEXT and IGTX) and	the extensions (".txt" and ".itx") are currently not used. But you should pass	some valid values anyway because a future XOP Toolkit might use them. If there	is no meaningful extension, leave the extension section blank.		The Format popup menu in the Save File dialog allows the user to tell you	in what format the file should be saved. Unlike the Show popup menu in the	Open File dialog, the Format menu has no filtering function. You find out	which item the user chose via the fileIndexPtr parameter.		The syntax of the formatMenuString is unforgiving. You must not use any	extraneous spaces or any other extraneous characters. You must include the	colons and semicolons as shown above. The trailing semicolon is required.	If there is a syntax error, the entire fileFilterString will be treated	as if it were empty, which will display all files.*/intXOPNavSaveFileDialog(const char* prompt, const char* formatMenuStr, int* fileIndexPtr, const char* proposedFileName, FSSpec* initialDirSpec, FSSpec* fileSpec){		NavReplyRecord theReply;	NavDialogOptions dialogOptions;	AEDesc defaultLocation;	AEDesc* defaultLocationPtr;	XOPNavCallbackData callbackData;	XOPNavFileTypeInfoHandle ftiH;	int numMenuItems;	int err;	NavEventUPP eventUPP = NewNavEventUPP(XOPNavFileEventProc);	NavMenuItemSpecArrayHandle menuItemSpecsH;		// Set default behavior for browser and dialog.	NavGetDefaultDialogOptions(&dialogOptions);	dialogOptions.dialogOptionFlags |= kNavDontAddTranslateItems;	dialogOptions.dialogOptionFlags &= ~kNavAllowStationery;		// XOP usually do not support stationery.	// CopyCStringToPascal("XOP Name", dialogOptions.clientName);	// Ideally, we would store the XOP name here, but we don't know it.	CopyCStringToPascal(prompt, dialogOptions.message);	CopyCStringToPascal(proposedFileName, dialogOptions.savedFileName);		// Prepare structure that is passed by Navigation Services to our event function.	MemClear(&callbackData, sizeof(callbackData));	callbackData.isSave = 1;		// Parse filter strings, if any. This defines Format menu items.	ftiH = NULL;	numMenuItems = 0;	if (*formatMenuStr != 0) {								// Not empty formatMenuStr?		XOPNavParseFileFilterString(formatMenuStr, &ftiH);	// ftiH will be NULL if formatMenuStr is not correctly formed.		if (ftiH != NULL)			numMenuItems = GetHandleSize((Handle)ftiH) / sizeof(XOPNavFileTypeInfo);	}	callbackData.ftiH = ftiH;	// If we are adding custom items to the Show menu, create structure to pass to Navigation services.	menuItemSpecsH = NULL;	if (numMenuItems>0 && ftiH!=NULL) {				// We want do filter files?		menuItemSpecsH = XOPNavGetMenuItemSpecsHandle(ftiH, numMenuItems);		dialogOptions.popupExtension = menuItemSpecsH;				/*	This is what will be initially selected in the Show popup menu.			By setting these fields, we make our filter function aware of that fact.		*/		if (fileIndexPtr != NULL) {						// If fileIndexPtr not null, honor the caller's request.			if (*fileIndexPtr > 0) {					// *fileIndexPtr is one-based.				if (*fileIndexPtr <= numMenuItems)					callbackData.index = *fileIndexPtr-1;			}		}	}	callbackData.menuItemSpecsH = menuItemSpecsH;			// Can be NULL. If so, Navigation Services will display all files.	// If we want to point the dialog to a particular initial folder, create the necessary structure.	defaultLocationPtr = NULL;	if (initialDirSpec != NULL) {		err = AECreateDesc(typeFSS, initialDirSpec, sizeof(FSSpec), &defaultLocation);		if (err == 0)			defaultLocationPtr = &defaultLocation;	}	/*	We have to pass kNavGenericSignature as the creator parameter in order to to fully		customize the Format popup menu. However, it is supported by Navigation Services 2.0		or later (Mac OS 9 or later), not by Navigation Services 1.1. Therefore, this code		will not work on Mac OS 8.6. It will return error -5966 (missing kind string).				Also, the fileType parameter has no meaning since we are using all custom		Format menu items. At least, that is my conclusion in the absence of any		guidance from Apple.	*/	{		OSType creator, fileType;		creator = kNavGenericSignature;		fileType = '\?\?\?\?';		err = NavPutFile(defaultLocationPtr, &theReply, &dialogOptions, eventUPP, fileType, creator, &callbackData);	}		// Let the caller know which custom menu item was chosen.	if (fileIndexPtr != NULL)		*fileIndexPtr = callbackData.index+1;	// *fileIndexPtr is one-based.		if (eventUPP != NULL)		DisposeNavEventUPP(eventUPP);	if (menuItemSpecsH != NULL)		DisposeHandle((Handle)menuItemSpecsH);	if (ftiH != NULL)		DisposeHandle((Handle)ftiH);	if (defaultLocationPtr)		AEDisposeDesc(defaultLocationPtr);		if (err == userCanceledErr)		return -1;	if (err != 0)		return err;	if (!theReply.validRecord)		return -1;					// Should not happen.	// Get FSSpec from Navigation Services reply record.	{		AEKeyword keyWord;		DescType typeCode;		Size actualSize;		// Retrieve the returned selection.		err = AEGetNthPtr(&theReply.selection, 1, typeFSS, &keyWord, &typeCode, fileSpec, sizeof(FSSpec), &actualSize);	}		NavDisposeReply(&theReply);		return err;}/*	Window Routines	These are Macintosh window routines that have no Windows equivalent.*//*	GetXOPWindow(windowID, wStorage, behind)	This routine is for Macintosh only.	Creates a window using the WIND resource with resource ID=windowID.	This resource must be in the XOPs resource fork.	wStorage and behind work as for the toolbox trap GetNewWindow.		Returns a window pointer if everything OK or NIL if couldn't get window.	Sets the windowKind field of the window equal to the XOPs refNum.	YOU MUST NOT CHANGE THE windowKind FIELD.		HR, 980317: Changed GetNewWindow to GetNewCWindow.*/WindowPtrGetXOPWindow(int windowID, char *wStorage, WindowPtr behind){	int curResNum;	Handle wHandle;	WindowPtr wPtr = NULL;		curResNum = CurResFile();	UseResFile(XOPRefNum());	wHandle = Get1Resource('WIND', windowID);	/* make sure resource exists in XOP file */	if (wHandle) {		wPtr = GetNewCWindow(windowID, wStorage, behind);		if (wPtr)			SetWindowKind(wPtr, XOPRefNum());		ReleaseResource(wHandle);	}	UseResFile(curResNum);	return(wPtr);}/*	Menu Routines	These are Classic Mac routines that are not supported by the Carbon SDK.	However, we need to support them in the XOP Toolkit because they are part	of a cross-platform (Mac and Win) set of routines and we don't want to	force Windows programmers to change their code just because Apple decided	not to support some old routines.*/shortCountMItems(MenuHandle theMenu){	return CountMenuItems(theMenu);}voidCheckItem(MenuHandle menuH, short itemNumber, int checked){	CheckMenuItem(menuH, itemNumber, checked);}voidDisableItem(MenuHandle menuH, short itemNumber){	DisableMenuItem(menuH, itemNumber);}voidEnableItem(MenuHandle menuH, short itemNumber){	EnableMenuItem(menuH, itemNumber);}voidgetmenuitemtext(MenuHandle theMenu, short itemNumber, char* itemString){	unsigned char pItemString[256];		GetMenuItemText(theMenu, itemNumber, pItemString);	CopyPascalStringToC(pItemString, itemString);}voidsetmenuitemtext(MenuHandle menuH, short itemNumber, char* itemString){	unsigned char pItemString[256];		CopyCStringToPascal(itemString, pItemString);	SetMenuItemText(menuH, itemNumber, pItemString);}voidinsertmenuitem(MenuHandle menuH, char *itemString, short afterItemOneBased){	unsigned char pItemString[256];		CopyCStringToPascal(itemString, pItemString);	InsertMenuItem(menuH, pItemString, afterItemOneBased);}voidappendmenu(MenuHandle menuH, char *itemString){	unsigned char pItemString[256];		CopyCStringToPascal(itemString, pItemString);	AppendMenuItemText(menuH, pItemString);}#include "XOPStructureAlignmentReset.h"	// Reset structure alignment to default.