/*	XOPDataFolderAccess.c		Routines for Igor XOPs that provide access to Igor Pro data folders.*/#include "XOPStandardHeaders.h"			// Include ANSI headers, Mac headers, IgorXOP.h, XOP.h and XOPSupport.h#include "XOPStructureAlignmentTwoByte.h"	// All structures passed between Igor and XOP are two-byte aligned.// *** Data Folder Access Routines ***/*	GetDataFolderNameOrPath(dataFolderH, flags, dataFolderPathOrName)	Given a handle to a data folder, returns		the name of the folder if bit 0 of flags is zero		a full path to the folder if bit 0 of flags is set		If bit 1 of flags is set, Igor returns the dataFolderPathOrName with	single quotes if they would be needed to use the name or path in Igor's	command line.		If bit 1 if flags is zero, dataFolderPathOrName will have no quotes.		Set bit 1 of flags if you are going to use the path or name in a command	that you submit to Igor via the XOPCommand or XOPSilentCommand callbacks.	Clear bit 1 of flags for other purpose, for example, if you are getting the	name or path just to display to the user.		All other bits of the flags parameter are reserved; you must set them to zero.		If dataFolderH is NIL, it uses the current data folder.		A data folder name can be up to MAX_OBJ_NAME characters while a full path	can be up to MAXCMDLEN characters. To be safe, allocate MAXCMDLEN+1 characters	for dataFolderPathOrName.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetDataFolderNameOrPath(DataFolderHandle dataFolderH, int flags, char dataFolderPathOrName[MAXCMDLEN+1]){	return CallBack3(GET_DATAFOLDER_NAMEORPATH, dataFolderH, (void*)flags, dataFolderPathOrName);}/*	GetDataFolderIDNumber(dataFolderH, IDNumberPtr)	Returns the unique ID number for the data folder via *IDNumberPtr.		If dataFolderH is NIL, it uses the current data folder.		Each data folder has a unique ID number that stays the same as long as the data	folder exists, even if it is renamed or moved. If you need to reference a data	folder over a period of time during which it could be killed, then you should	store the data folder's ID number.		Given the ID number, you can call GetDataFolderByIDNumber to check if the data	folder still exists and to get a handle it.		The ID number is valid until the user creates a new Igor experiment or quits Igor.	ID numbers are not remembered from one running of Igor to the next.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetDataFolderIDNumber(DataFolderHandle dataFolderH, long* IDNumberPtr){	return CallBack2(GET_DATAFOLDER_IDNUMBER, dataFolderH, IDNumberPtr);}/*	GetDataFolderProperties(dataFolderH, propertiesPtr)	Returns the bit-flag properties of the specified data folder.		If dataFolderH is NIL, it uses the current data folder.		At present, Igor does not support any properties and this routine will always return 0	in *propertiesPtr. In the future, it might support properties such as "locked".		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetDataFolderProperties(DataFolderHandle dataFolderH, long* propertiesPtr){	return CallBack2(GET_DATAFOLDER_PROPERTIES, dataFolderH, propertiesPtr);}/*	SetDataFolderProperties(dataFolderH, properties)	Sets the bit-flag properties of the specified data folder.		If dataFolderH is NIL, it uses the current data folder.		At present, Igor does not support any properties and there is no reason	to call this routine. It will return a -1 error code for any value	of properties other than 0.		In the future, it might support properties such as "locked".		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intSetDataFolderProperties(DataFolderHandle dataFolderH, long properties){	return CallBack2(SET_DATAFOLDER_PROPERTIES, dataFolderH, (void*)properties);}/*	GetDataFolderListing(dataFolderH, optionsFlag, h)	Returns via the handle h a listing of the contents of the specified data folder.	You must create h and dispose it when you no longer need it. Its contents will	be replaced by the listing.		The listing does not include a null terminator character. Use GetHandleSize to	find the length of the text and add a null terminator if you want to treat it	as a C string.		If dataFolderH is NIL, it uses the current data folder.		optionsFlag determines what is in the listing.		If bit 0 of optionsFlag is set:			includes "FOLDERS:<subFolder0>,<subFolder1>...,<subFolderN>;<CR>"		If bit 1 of optionsFlag is set:			includes "WAVES:<waveName0>,<waveName1>...,<waveNameN>;<CR>"		If bit 2 of optionsFlag is set:			includes "VARIABLES:<variableName0>,<variableName1>...,<variableNameN>;<CR>"		If bit 3 of optionsFlag is set:			includes "STRINGS:<stringVariableName0>,<stringVariableName1>...,<stringVariableNameN>;<CR>"		All other bits are reserved and should be set to zero.	Names in the listing of waves, variables and strings are quoted with single	quotes if this is necessary to make them suitable for use in the Igor command line.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetDataFolderListing(DataFolderHandle dataFolderH, int optionsFlag, Handle h){	return CallBack3(GET_DATAFOLDER_LISTING, dataFolderH, (void*)optionsFlag, h);}/*	int GetRootDataFolder(refNum, rootDataFolderHPtr);	Returns a handle to the root data folder.		Data folder handles belong to Igor so you should not modify or dispose them.		NOTE: Always pass 0 for refNum. It is for future use.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/int GetRootDataFolder(long refNum, DataFolderHandle* rootDataFolderHPtr){	return CallBack2(GETROOT_DATAFOLDER, (void*)refNum, rootDataFolderHPtr);}/*	GetCurrentDataFolder(currentDataFolderHPtr)	Returns a handle to the current data folder in *currentDataFolderHPtr.		Data folder handles belong to Igor so you should not modify or dispose them.		The only use for this handle is to pass it to other data-folder-related	XOPSupport routines.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetCurrentDataFolder(DataFolderHandle* currentDataFolderHPtr){	return CallBack1(GETCURRENT_DATAFOLDER, currentDataFolderHPtr);}/*	SetCurrentDataFolder(dataFolderH)	Sets the current data folder to the data folder referenced by dataFolderH.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intSetCurrentDataFolder(DataFolderHandle dataFolderH){	return CallBack1(SETCURRENT_DATAFOLDER, dataFolderH);}/*	GetNamedDataFolder(startingDataFolderH, dataFolderPath, dataFolderHPtr)	Returns in *dataFolderHPtr the data folder specified by startingDataFolderH and dataFolderPath.	Data folder handles belong to Igor so you should not modify or dispose them.		dataFolderPath can be an absolute path (e.g., "root:FolderA:FolderB:"), a relative	path (e.g., ":FolderA:FolderB:") or a data folder name (e.g., "FolderA").		If dataFolderPath is an absolute path then startingDataFolderH is immaterial - you	can pass any data folder handle or NIL. An absolute path must always start with "root:".	It should include a trailing colon but GetNamedDataFolder tolerates an absolute path	without the trailing colon. Note that "root" is an not an absolute path whereas "root:" is.	If dataFolderPath is a relative path or a data folder name then dataFolderPath is relative	to startingDataFolderH. However, if startingDataFolderH is NIL then dataFolderPath is relative	to the current folder.		Passing "root" as dataFolderPath will not find the root data folder because "root" is a	data folder name. Igor will try to find a data folder named "root" relative to the current	data folder. The actual root data folder is never relative to any data folder so it can	not be found this way. Use "root:" instead.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetNamedDataFolder(DataFolderHandle startingDataFolderH, char dataFolderPath[MAXCMDLEN+1], DataFolderHandle* dataFolderHPtr){	char path[MAXCMDLEN+1];	char* p;	long len;		p = dataFolderPath;		// This is a workaround for a bug in Igor Pro 3.00 that was fixed in 3.01.	if (igorVersion < 301) {		len = strlen(dataFolderPath);		if (len > MAXCMDLEN) {			*dataFolderHPtr = NIL;			return CANT_FIND_FOLDER;		}		strcpy(path, dataFolderPath);		p = path;		if (path[len-1] == ':') {					// Igor Pro 3.0 does not tolerate trailing colon.			path[len-1] = 0;			if (*path == 0) {						// Original path was ":" ?				int err = 0;				if (startingDataFolderH == NIL)					err = GetCurrentDataFolder(dataFolderHPtr);				else					*dataFolderHPtr = startingDataFolderH;					return err;			}			if (CmpStr(path, "root") == 0)			// Original path was "root:" ?				return GetRootDataFolder(0, dataFolderHPtr);		}	}	// End of workaround.		return CallBack3(GETNAMED_DATAFOLDER, startingDataFolderH, p, dataFolderHPtr);}/*	GetDataFolderByIDNumber(IDNumber, dataFolderHPtr)	Returns via *dataFolderHPtr the data folder handle associated with the	specified ID number.		Data folder handles belong to Igor so you should not modify or dispose them.		Returns 0 if OK or a non-zero error code if the data folder doesn't exist,	which would be the case if the data folder were killed since you got its	ID number.		Each data folder has a unique ID number that stays the same as long as the data	folder exists. You can get the ID number for a data folder using GetDataFolderIDNumber().		If you need to reference a data folder over a period of time during which it	could be killed, then you should store the data folder's ID number. Given the ID	number, GetDataFolderByIDNumber tells you if the data folder still exists and,	if it does, gives you the data folder handle.		The ID number is valid until the user creates a new Igor experiment or quits Igor.	ID numbers are not remembered from one running of Igor to the next.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetDataFolderByIDNumber(long IDNumber, DataFolderHandle* dataFolderHPtr){	return CallBack2(GET_DATAFOLDER_BYIDNUMBER, (void*)IDNumber, dataFolderHPtr);}/*	GetParentDataFolder(dataFolderH, parentFolderHPtr)	Returns the parent of the specified data folder via *parentFolderHPtr.		Data folder handles belong to Igor so you should not modify or dispose them.		If dataFolderH is NIL, it uses the current data folder.		Passing the root data folder as dataFolderH is an error. In this	case GetParentDataFolder returns NO_PARENT_DATAFOLDER.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetParentDataFolder(DataFolderHandle dataFolderH, DataFolderHandle* parentFolderHPtr){	return CallBack2(GETPARENT_DATAFOLDER, dataFolderH, parentFolderHPtr);}/*	int GetNumChildDataFolders(parentDataFolderH, numChildDataFolderPtr)	Returns the number of child data folders in the specified parent data folder.	If parentDataFolderH is NIL, it uses the current data folder.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetNumChildDataFolders(DataFolderHandle parentDataFolderH, long* numChildDataFolderPtr){	return CallBack2(GETNUMCHILD_DATAFOLDERS, parentDataFolderH, (void*)numChildDataFolderPtr);}/*	int GetIndexedChildDataFolder(parentDataFolderH, index, childDataFolderHPtr)	Returns a handle to the child data folder specified by the index.	index starts from 0.		Data folder handles belong to Igor so you should not modify or dispose them.		If parentDataFolderH is NIL, it uses the current data folder.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetIndexedChildDataFolder(DataFolderHandle parentDataFolderH, long index, DataFolderHandle* childDataFolderHPtr){	return CallBack3(GETINDEXEDCHILD_DATAFOLDER, parentDataFolderH, (void*)index, childDataFolderHPtr);}/*	GetWavesDataFolder(wavH, dataFolderHPtr)	Returns the handle to the data folder containing the specified wave.		Data folder handles belong to Igor so you should not modify or dispose them.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetWavesDataFolder(waveHndl wavH, DataFolderHandle* dataFolderHPtr){	return CallBack2(GETWAVES_DATAFOLDER, wavH, dataFolderHPtr);}/*	NewDataFolder(parentFolderH, newDataFolderName, newDataFolderHPtr)	Creates a new data folder in the data folder specified by parentFolderH.		parentFolderH can be		a handle to an Igor data folder		NIL to use the current data folder		On output, *newDataFolderHPtr will contain a handle to the new data folder	or NIL if an error occurred.		Data folder handles belong to Igor so you should not modify or dispose them.		NewDataFolder does not change the current data folder. If you want to make the	new folder the current folder, call SetCurrentDataFolder after NewDataFolder.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intNewDataFolder(DataFolderHandle parentFolderH, char newDataFolderName[MAX_OBJ_NAME+1], DataFolderHandle* newDataFolderHPtr){	return CallBack3(NEW_DATAFOLDER, parentFolderH, newDataFolderName, newDataFolderHPtr);}/*	KillDataFolder(dataFolderH)	Kills an existing data folder, removing it and its contents, including	any child data folders, from memory.		dataFolderH is a handle to an existing Igor data folder or NIL to use	the current data folder.	You will receive an error and the data folder will not be killed if it	contains waves or variables that are in use (e.g. displayed in tables or graphs).		If you kill the current data folder or a data folder that contains the current	data folder, Igor will set the current data folder to the parent of the killed	data folder.		If you kill the root data folder, its contents will be killed but not	the root data folder itself.		Returns 0 or error code.		NOTE: Once a data folder is successfully killed, dataFolderH is no longer		  valid. You should not reference it for any purpose.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intKillDataFolder(DataFolderHandle dataFolderH){	return CallBack1(KILL_DATAFOLDER, dataFolderH);}/*	DuplicateDataFolder(sourceDataFolderH, parentDataFolderH, newDataFolderName)	Creates a clone of the source data folder. The contents of the destination	will be clones of the contents of the source.		sourceDataFolderH is a handle to the data folder to be duplicated	or NIL to use the current data folder.	parentDataFolderH is a handle to the data folder in which the new data folder	is to be created or NIL to use the current data folder.		newDataFolderName is the name to be given to the new data folder.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intDuplicateDataFolder(DataFolderHandle sourceDataFolderH, DataFolderHandle parentDataFolderH, char newDataFolderName[MAX_OBJ_NAME+1]){	return CallBack3(DUPLICATE_DATAFOLDER, sourceDataFolderH, parentDataFolderH, newDataFolderName);}/*	MoveDataFolder(sourceDataFolderH, newParentDataFolderH)		Moves the source data folder into a new location in the hierarchy.	It is an error to attempt to move a parent folder into itself or	one of its children.		sourceDataFolderH is a handle to the data folder to be moved	or NIL to use the current data folder.	newParentDataFolderH is a handle to the data folder in which the source data folder	is to be moved or NIL to use the current data folder.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.	*/intMoveDataFolder(DataFolderHandle sourceDataFolderH, DataFolderHandle newParentDataFolderH){	return CallBack2(MOVE_DATAFOLDER, sourceDataFolderH, newParentDataFolderH);}/*	RenameDataFolder(dataFolderH, newName)		Renames the data folder.		dataFolderH is a handle to the data folder to be renamed or NIL to use	the current data folder.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.	*/intRenameDataFolder(DataFolderHandle dataFolderH, char newName[MAX_OBJ_NAME+1]){	return CallBack2(RENAME_DATAFOLDER, dataFolderH, newName);}/*	GetNumDataFoldersObjects(dataFolderH, int objectType, numObjectsPtr)	Returns via numObjectsPtr the number of objects of the specified type in the	specified data folder.	If dataFolderH is NIL, it uses the current data folder.		objectType is one of the following:		WAVE_OBJECT		for waves		VAR_OBJECT		for numeric variables		STR_OBJECT		for string variables		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetNumDataFolderObjects(DataFolderHandle dataFolderH, int objectType, long* numObjectsPtr){	return CallBack3(GETNUM_DATAFOLDER_OBJECTS, dataFolderH, (void*)objectType, (void*)numObjectsPtr);}/*	GetIndexedDataFolderObject(dataFolderH, objectType, index, objectName, objectValuePtr)	Returns information that allows you to access an object of the specified type in the	specified data folder.	index starts from 0.	If dataFolderH is NIL, it uses the current data folder.		objectType is one of the following:		WAVE_OBJECT		for waves		VAR_OBJECT		for numeric variables		STR_OBJECT		for string variables		You can pass NIL for objectName if you don't need to know the name of the object.	If you do not want to get the "value" of the object, pass NIL for objectValuePtr.	If objectValuePtr is not NIL, GetIndexedDataFolderObject sets fields depending	on the object's type:		WAVE_OBJECT		sets objectValuePtr->wavH field to wave's handle		VAR_OBJECT		stores numeric variable's value in objectValuePtr->nv field		STR_OBJECT		sets objectValuePtr->strH field to strings's handle		The handles returned via the wavH and strH fields belong to Igor. Do not	modify or dispose them.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetIndexedDataFolderObject(DataFolderHandle dataFolderH, int objectType, long index, char objectName[MAX_OBJ_NAME+1], DataObjectValuePtr objectValuePtr){	return CallBack5(GETINDEXED_DATAFOLDER_OBJECT, dataFolderH, (void*)objectType, (void*)index, objectName, objectValuePtr);}/*	GetDataFolderObject(dataFolderH, objectName, objectTypePtr, objectValuePtr)		Returns 0 if the object exists or an error code if it does not exist.		Returns the object type (WAVE_OBJECT, VAR_OBJECT, STR_OBJECT or DATAFOLDER_OBJECT	via objectTypePtr.	If dataFolderH is NIL, it uses the current data folder.		If objectValuePtr is not NIL, it returns:		For WAVE_OBJECT:		A handle to the wave via the objectValuePtr->wavH field.		For VAR_OBJECT:			The value of the variable via the objectValuePtr->nv field.		For STR_OBJECT:			A handle to the strings contents via the objectValuePtr->strH field.		For DATAFOLDER_OBJECT:	A handle to the data folder via the objectValuePtr->dfH field.		Note that the wave, string and data folder handles returned belong to Igor.	The caller should not modify or dispose them.		Remember also that strings in handles do not contain a null terminator (they are not C strings).	To find the number of characters, call GetHandleSize on the handle.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intGetDataFolderObject(DataFolderHandle dataFolderH, char objectName[MAX_OBJ_NAME+1], int* objectTypePtr, DataObjectValuePtr objectValuePtr){	long objectType;	int err;	err= CallBack4(GET_DATAFOLDER_OBJECT, dataFolderH, objectName, &objectType, objectValuePtr);	*objectTypePtr = objectType;	return err;}/*	SetDataFolderObject(dataFolderH, objectName, objectType, objectValuePtr)		Returns 0 if the object exists or an error code if it does not exist	or is of the wrong type.	If dataFolderH is NIL, it uses the current data folder.		If objectValuePtr is not NIL, it does the following:		For WAVE_OBJECT:		Does nothing.				For VAR_OBJECT:			Sets the value of the numeric variable based on objectValuePtr->nv.								Note that you can't change between real and complex by changing								the nv numType field.										For STR_OBJECT:			Sets the value of the string variable based on objectValuePtr->strH.								Igor just copies the data from the handle. The handle is yours to dispose								(if you created it).								Remember also that strings in handles do not contain a null terminator								(they are not C strings). To find the number of characters, call								GetHandleSize on the handle.										For DATAFOLDER_OBJECT:	Does nothing.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intSetDataFolderObject(DataFolderHandle dataFolderH, char objectName[MAX_OBJ_NAME+1], int objectType, DataObjectValuePtr objectValuePtr){	return CallBack4(SET_DATAFOLDER_OBJECT, dataFolderH, objectName, (void*)objectType, objectValuePtr);}/*	KillDataFolderObject(dataFolderH, objectType, objectName)	Kills the named object of the specified type in the specified data folder.	If dataFolderH is NIL, it uses the current data folder.		objectType is one of the following:		WAVE_OBJECT		for waves		VAR_OBJECT		for numeric variables		STR_OBJECT		for string variables		NOTE: If you attempt to kill a wave that is in use (e.g. in a graph, table or user function)		  the wave will not be killed and you will receive a non-zero error code.		  Igor does not check if numeric and string variables are in use. You can		  kill a numeric or string variable at any time without receiving an error.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intKillDataFolderObject(DataFolderHandle dataFolderH, int objectType, char objectName[MAX_OBJ_NAME+1]){	return CallBack3(KILL_DATAFOLDER_OBJECT, dataFolderH, (void*)objectType, objectName);}/*	MoveDataFolderObject(sourceDataFolderH, objectType, objectName, destDataFolderH)	Moves the named object of the specified type from the source data folder to the	destination data folder.	If sourceDataFolderH is NIL, it uses the current data folder.	If destDataFolderH is NIL, it uses the current data folder.		objectType is one of the following:		WAVE_OBJECT		for waves		VAR_OBJECT		for numeric variables		STR_OBJECT		for string variables		NOTE: If an object with the same name exists in the destination data folder,		  the object will not be moved and you will receive a non-zero error code.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intMoveDataFolderObject(DataFolderHandle sourceDataFolderH, int objectType, char objectName[MAX_OBJ_NAME+1], DataFolderHandle destDataFolderH){	return CallBack4(MOVE_DATAFOLDER_OBJECT, sourceDataFolderH, (void*)objectType, objectName, destDataFolderH);}/*	RenameDataFolderObject(dataFolderH, objectType, objectName, newObjectName)	Renames the named object of the specified type in the specified data folder.	If dataFolderH is NIL, it uses the current data folder.		objectType is one of the following:		WAVE_OBJECT		for waves		VAR_OBJECT		for numeric variables		STR_OBJECT		for string variables		NOTE: If the new name is illegal or in use the object will not be renamed and you will		  receive a non-zero error code.		Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intRenameDataFolderObject(DataFolderHandle dataFolderH, int objectType, char objectName[MAX_OBJ_NAME+1], char newObjectName[MAX_OBJ_NAME+1]){	return CallBack4(RENAME_DATAFOLDER_OBJECT, dataFolderH, (void*)objectType, objectName, newObjectName);}/*	DuplicateDataFolderObject(dataFolderH, objectType, objectName, destFolderH, newObjectName, overwrite)	Duplicates the named object of the specified type.		If dataFolderH and/or destFolderH is NIL, it uses the current data folder.		objectType is one of the following:		WAVE_OBJECT		for waves		VAR_OBJECT		for numeric variables		STR_OBJECT		for string variables		If the new name is illegal you will receive a non-zero error code.	If the new name is in use and overwrite is false, you will receive a non-zero error code.	If the new name is in use for a different kind of object, you will receive a non-zero error code.	To avoid these errors, you can check and if necessary fix the new name using the CheckName,	CleanupName and UniqueName2 routines.	Returns 0 or error code.	Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no data folders.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intDuplicateDataFolderObject(	DataFolderHandle dataFolderH, int objectType, char objectName[MAX_OBJ_NAME+1],	DataFolderHandle destFolderH, char newObjectName[MAX_OBJ_NAME+1], int overwrite){	return CallBack6(DUPLICATE_DATAFOLDER_OBJECT, dataFolderH, (void*)objectType, objectName, destFolderH, newObjectName, (void*)overwrite);}/*	ClearDataFolderFlags()	This routine is for use by the WaveMetrics Data Browser only.			Added in Igor Pro 3.0. If you call this when running with an earlier version,	you will receive the IGOR_OBSOLETE error code as the function result.*/voidClearDataFolderFlags(void){	CallBack0(CLEAR_DATAFOLDER_FLAGS);}/*	GetDataFolderChangesCount()	This routine is for use by the WaveMetrics Data Browser only.			Added in Igor Pro 3.0. If you call this when running with an earlier version,	you will receive the IGOR_OBSOLETE error code as the function result.*/longGetDataFolderChangesCount(void){	return CallBack0(GET_DATAFOLDER_CHANGESCOUNT);}/*	GetDataFolderChangeFlags(dataFolderH, flagsP)	This routine is for use by the WaveMetrics Data Browser only.			Added in Igor Pro 3.0. If you call this when running with an earlier version,	you will receive the IGOR_OBSOLETE error code as the function result.*/intGetDataFolderChangeFlags(DataFolderHandle dataFolderH, long *flagsP){	return CallBack2(GET_DATAFOLDER_CHANGEFLAGS, dataFolderH, (long*)flagsP);}#include "XOPStructureAlignmentReset.h"	// Reset structure alignment to default.