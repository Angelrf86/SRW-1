/*	This file contains utilities for XOPs that open, read and write files.	This includes file-loader specific routines.		HR, 10/8/96: Split these routines out from XOPSupport.c.*/#include "XOPStandardHeaders.h"			// Include ANSI headers, Mac headers, IgorXOP.h, XOP.h and XOPSupport.h#include "XOPStructureAlignmentTwoByte.h"	// All structures passed between Igor and XOP are two-byte aligned.#ifdef _MACINTOSH_/*	HFSToPosixPath(hfsPath, posixPath[MAX_PATH_LEN+1], isDirectory)	Converts an HFS (colon-separated) path into a POSIX (Unix-style) path.	This is used only on Mac OS X and only to convert paths into POSIX paths	so that we can pass them to the standard file routines fopen.		It is allowed for hfsPath and posixPath to point to the same memory.		From the point of view of the Igor user, all paths should be HFS paths	although Windows paths are accepted and converted when necessary. POSIX	paths are not valid paths in Igor procedures.				Returns 0 if OK or an error code. If an error is returned, *posixPath is undefined.*/intHFSToPosixPath(const char* hfsPath, char posixPath[MAX_PATH_LEN+1], int isDirectory){	CFStringRef cfHFSPath = NULL;	CFURLRef cfURLPath = NULL;	CFStringEncoding encoding = kCFStringEncodingMacRoman;	int err;		err = 0;		encoding = CFStringGetSystemEncoding();			// As set in International control panel.		cfHFSPath = CFStringCreateWithCString(NULL, hfsPath, encoding);	if (cfHFSPath == NULL) {		err = NOMEM;								// We have no way to know what the real error is.		goto done;	}	// Make a CFURLRef from the CFString representation of the bundle's path.	cfURLPath = CFURLCreateWithFileSystemPath(NULL, cfHFSPath, kCFURLHFSPathStyle, isDirectory);	if (cfURLPath == NULL) {		err = FILE_OPEN_ERROR;						// We have no way to know what the real error is.		goto done;	}		if (CFURLGetFileSystemRepresentation(cfURLPath, 1, (unsigned char*)posixPath, MAX_PATH_LEN) == 0)		err = PATH_TOO_LONG;done:	if (cfHFSPath != NULL)		CFRelease(cfHFSPath);	if (cfURLPath != NULL)		CFRelease(cfURLPath);	return err;}#endif		// _MACINTOSH_/*	XOPCreateFile(fullFilePath, overwrite, macCreator, macFileType)	Creates a file with the location and name specified by fullFilePath.		fullFilePath must be a native path.	If overwrite is true and a file by that name already exists, it first	deletes the conflicting file. If overwrite is false and a file by that	name exists, it returns an error.		macFileType is ignored on Windows. On Macintosh, it is used to set	the new file's type. For example, use 'TEXT' for a text file.		macCreator is ignored on Windows. On Macintosh, it is used to set	the new file's creator code. For example, use 'IGR0' (last character is zero)	for an file.		Returns 0 if OK or an error code.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intXOPCreateFile(const char* fullFilePath, int overwrite, long macCreator, long macFileType){	int err;		if (igorVersion < 313)		return IGOR_OBSOLETE;					// Because FullPathPointsToFile requires Igor Pro 3.13 or later.		if (FullPathPointsToFile(fullFilePath)) {		if (overwrite) {			if (err = XOPDeleteFile(fullFilePath))				return err;		}		else {			return FILE_CREATE_ERROR;		}	}	#ifdef _MACINTOSH_	{		FSSpec spec;		unsigned char temp[MAX_PATH_LEN+1];			if (strlen(fullFilePath) > 255)			return PATH_TOO_LONG;				// Because we use FSMakeFSSpec and FSpCreate which take a Pascal string with can not exceed 255 characters.				CopyCStringToPascal(fullFilePath, temp);		if (err = FSMakeFSSpec(0, 0, temp, &spec)) {			if (err == fnfErr)					// It's OK if the file does not exist.				err = 0;			if (err != 0)				return err;		}				if (err = FSpCreate(&spec, macCreator, macFileType, smSystemScript))			return err;				return 0;	}	#endif		#ifdef _WINDOWS_	{		HANDLE fileH;		long accessMode, shareMode;				err = 0;		accessMode = GENERIC_READ | GENERIC_WRITE;		shareMode = 0;		fileH = CreateFile(fullFilePath, accessMode, shareMode, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);		if (fileH == INVALID_HANDLE_VALUE)			err = WMGetLastError();		else			CloseHandle(fileH);		return err;	}	#endif}/*	XOPDeleteFile(fullFilePath)	Deletes the file specified by fullFilePath.		fullFilePath must be a native path.		Returns 0 if OK or an error code.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPDeleteFile(const char* fullFilePath){	#ifdef _MACINTOSH_	{		FSSpec spec;		unsigned char temp[MAX_PATH_LEN+1];		int err;			if (strlen(fullFilePath) > 255)			return PATH_TOO_LONG;					// Because we use FSMakeFSSpec and FSpDelete which take a Pascal string with can not exceed 255 characters.				CopyCStringToPascal(fullFilePath, temp);		if (err = FSMakeFSSpec(0, 0, temp, &spec))			return err;				if (err = FSpDelete(&spec))			return err;				return 0;	}	#endif		#ifdef _WINDOWS_	{		int err;		err = 0;		if (DeleteFile(fullFilePath) == 0)			err = WMGetLastError();		return err;	}	#endif}/*	XOPOpenFile(fullFilePath, readOrWrite, fileRefPtr)	If readOrWrite is zero, opens an existing file for reading and returns a file reference	via fileRefPtr.	If readOrWrite is non-zero, opens an existing file for writing or creates a new	file if none exists and returns a file reference via fileRefPtr.	fullFilePath must be a native path except that, if you are compiling with Xcode	for Mac OS X, it can be either a native (HFS) or POSIX path.		Returns 0 if OK or an error code.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPOpenFile(const char* fullFilePath, int readOrWrite, XOP_FILE_REF* fileRefPtr){	char path[MAX_PATH_LEN+1];		if (strlen(fullFilePath) > MAX_PATH_LEN)		return PATH_TOO_LONG;	strcpy(path, fullFilePath);	#ifdef _MACINTOSH_		#if TARGET_RT_MAC_MACHO			/*	If here, we are compiling a Mac OS X Mach-O XOP using CodeWarrior or Xcode.				In this case, fopen expects a POSIX path. In CodeWarrior CFM, fopen expects				an HFS path.			*/			if (*path != '/') {	// Don't try to convert to POSIX if the calling routine has already done it.				int err;				if (err = HFSToPosixPath(path, path, 0))					return err;						}		#endif	#endif	*fileRefPtr = fopen(path, readOrWrite ? "wb" : "rb");	if (*fileRefPtr == NULL)		return FILE_OPEN_ERROR;	return 0;}/*	XOPCloseFile(fileRef)	Closes the referenced file.		Returns 0 if OK or an error code.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPCloseFile(XOP_FILE_REF fileRef){	if (fclose(fileRef))		return FILE_CLOSE_ERROR;	return 0;}/*	XOPReadFile(fileRef, count, buffer, numBytesReadPtr)	Reads count bytes from the referenced file into the buffer.		If numBytesReadPtr is not NULL, stores the number of bytes read in	*numBytesReadPtr.		Returns 0 if OK or an error code.		If bytes remain to be read in the file and you ask to read more bytes	than remain, the remaining bytes are returned and the function result is	zero. If no bytes remain to be read in the file and you ask to read bytes,	no bytes are returned and the function result is FILE_EOF_ERROR.		XOPReadFile is appropriate when you are reading data of variable size, in	which case you do not want to consider it an error if the end of file is reached	before reading all of the bytes that you requested. If you are reading a	record of fixed size, use use XOPReadFile2 instead of XOPReadFile.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPReadFile(XOP_FILE_REF fileRef, unsigned long count, void* buffer, unsigned long* numBytesReadPtr){	unsigned long numBytesRead;		if (count == 0) {		if (numBytesReadPtr != NULL)			*numBytesReadPtr = 0;		return 0;	}		clearerr(fileRef);	numBytesRead = fread(buffer, 1, count, fileRef);	if (numBytesReadPtr != NULL)		*numBytesReadPtr = numBytesRead;	if (ferror(fileRef))		return FILE_READ_ERROR;	if (numBytesRead==0 && XOPAtEndOfFile(fileRef))		return FILE_EOF_ERROR;			// We were at the end of file when asked to read some bytes.	return 0;}/*	XOPReadFile2(fileRef, count, buffer, numBytesReadPtr)	Reads count bytes from the referenced file into the buffer.		If numBytesReadPtr is not NULL, stores the number of bytes read in	*numBytesReadPtr.		Returns 0 if OK or an error code.		If bytes remain to be read in the file and you ask to read more bytes	than remain, the remaining bytes are returned and the function result is	FILE_EOF_ERROR.		XOPReadFile2 is appropriate when you are reading a record of fixed size, in	which case you want to consider it an error if the end of file is reached	before reading all of the bytes in the record. If you are reading a record	of variable size then you should use XOPReadFile instead of XOPReadFile2.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPReadFile2(XOP_FILE_REF fileRef, unsigned long count, void* buffer, unsigned long* numBytesReadPtr){	unsigned long numBytesRead;		if (count == 0) {		if (numBytesReadPtr != NULL)			*numBytesReadPtr = 0;		return 0;	}		clearerr(fileRef);	numBytesRead = fread(buffer, 1, count, fileRef);	if (numBytesReadPtr != NULL)		*numBytesReadPtr = numBytesRead;	if (ferror(fileRef))		return FILE_READ_ERROR;	if (numBytesRead < count) {				// We did not read all of the bytes requested.		if (XOPAtEndOfFile(fileRef))			return FILE_EOF_ERROR;			// We hit the end of file.		return FILE_READ_ERROR;				// Some other occurred but ferror did not reflect it.	}	return 0;}/*	XOPWriteFile(fileRef, count, buffer, numBytesWrittenPtr)	Writes count bytes from the buffer to the referenced file.		If numBytesWrittenPtr is not NULL, stores the number of bytes written in	*numBytesWrittenPtr.		Returns 0 if OK or an error code.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPWriteFile(XOP_FILE_REF fileRef, unsigned long count, const void* buffer, unsigned long* numBytesWrittenPtr){	unsigned long numBytesWritten;		if (count == 0) {		if (numBytesWrittenPtr != NULL)			*numBytesWrittenPtr = 0;		return 0;	}		numBytesWritten = fwrite(buffer, 1, count, fileRef);	if (numBytesWrittenPtr != NULL)		*numBytesWrittenPtr = numBytesWritten;	if (numBytesWritten != count)		return FILE_WRITE_ERROR;	return 0;}/*	XOPGetFilePosition(fileRef, filePosPtr)	Returns via filePosPtr the current file position of the referenced file.		Returns 0 if OK or an error code.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPGetFilePosition(XOP_FILE_REF fileRef, unsigned long* filePosPtr){	long pos;		pos = ftell(fileRef);	if (pos == -1L)		return FILE_POS_ERROR;	*filePosPtr = pos;	return 0;}/*	XOPSetFilePosition(fileRef, filePos, mode)	Sets the current file position in the referenced file.		If mode is -1, then filePos is relative to the start of the file.	If mode is 0, then filePos is relative to the current file position.	If mode is 1, then filePos is relative to the end of the file.		Returns 0 if OK or an error code.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPSetFilePosition(XOP_FILE_REF fileRef, long filePos, int mode){	int seekMode;		switch(mode) {		case -1:			seekMode = SEEK_SET;			break;		case 0:			seekMode = SEEK_CUR;			break;		case 1:			seekMode = SEEK_END;			break;		default:			return FILE_POS_ERROR;	}		if (fseek(fileRef, filePos, seekMode) != 0)		return FILE_POS_ERROR;	return 0;}/*	XOPAtEndOfFile(fileRef)	Returns 1 if the current file position is at the end of file, 0 if not.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPAtEndOfFile(XOP_FILE_REF fileRef){	if (feof(fileRef))				// Hit end of file?		return 1;	return 0;}/*	XOPNumberOfBytesInFile(fileRef, numBytesPtr)	Returns via numBytesPtr the total number of bytes in the referenced file.		Returns 0 if OK or an error code.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPNumberOfBytesInFile(XOP_FILE_REF fileRef, unsigned long* numBytesPtr){	long originalPos;	originalPos = ftell(fileRef);	if (fseek(fileRef, 0, SEEK_END) != 0)		return FILE_POS_ERROR;	*numBytesPtr = ftell(fileRef);	if (*numBytesPtr == -1L)		return FILE_POS_ERROR;	if (fseek(fileRef, originalPos, SEEK_SET) != 0)		return FILE_POS_ERROR;	return 0;}/*	XOPReadLine(fileRef, buffer, bufferLength)	buffer points to a buffer into which the line of data is to be read.		bufferLength is the size of the buffer. The buffer can hold bufferLength-1	characters, plus the terminating null character.		A line in the file may end with:		<end-of-file>		CR		LF		CRLF		XOPReadLine reads the next line of text into the buffer and null-terminates it.	The terminating CR, LF, or CRLF is not stored in the buffer.		If numBytesReadPtr is not NULL, stores the number of bytes read in	*numBytesReadPtr.		Returns 0 if OK or a non-zero error code.		The function result will be LINE_TOO_LONG_IN_FILE if there is not enough room in the	buffer to read the entire line. It will be FILE_EOF_ERROR if we hit the end-of-file	before reading any characters. It will be zero if we read any characters	(even just a CR or LF) before hitting the end of the file.		This routine was designed for simplicity of use. For applications that require	blazing speed (e.g., reading files containing tens of thousands of lines or more),	a more complex buffering scheme can improve performance considerably.		Added for Igor Pro 3.13 but works with any version. However, some error	codes returned require Igor Pro 3.13 or later, so you will get bogus error	messages if you return these error codes to earlier versions of Igor.*/intXOPReadLine(XOP_FILE_REF fileRef, char* buffer, unsigned long bufferLength, unsigned long* numBytesReadPtr){	char* bufPtr;	char ch;	int done;	unsigned long count, numBytesRead, numBytesToPutBack;	int err;		/*	The nominalLineLength variable is used to attempt to tune this routine		to the actual line length encountered.			Ideally, we would read the exact right number of characters each time		we are called to read a line. This is not possible. The next best thing		is to read slightly more characters than we need so that we go through		the outer loop below only once.	*/	static unsigned long nominalLineLength = 80;		bufPtr = buffer;		done = 0;	numBytesToPutBack = 0;	numBytesRead = 0;	while(!done) {		count = bufferLength - numBytesRead - 1;		// Maximum that could be read.		if (count <= 0) {			err = LINE_TOO_LONG_IN_FILE;			break;		}		if (count > nominalLineLength)			count = nominalLineLength;					// Maximum that we want to read at one time.				err = XOPReadFile(fileRef, count, bufPtr, &count);		if (err != 0) {			if (numBytesRead>0 && XOPAtEndOfFile(fileRef))				err = 0;			break;		}				while(count > 0) {			if (*bufPtr==CR_CHAR) {				if (count > 1) {					// Check for LF following CR.					numBytesToPutBack = count-1;					if (bufPtr[1] == LF_CHAR)						numBytesToPutBack -= 1;				}				else {					// Need to read another character in order to check for LF following CR.					XOPReadFile(fileRef, 1, &ch, &count);					if (count>0 && ch!=LF_CHAR)						numBytesToPutBack = 1;				}				done = 1;				break;			}			else {				if (*bufPtr==LF_CHAR) {					numBytesToPutBack = count-1;					done = 1;					break;				}			}			bufPtr += 1;			numBytesRead += 1;			count -= 1;		}	}		if (numBytesToPutBack > 0)		XOPSetFilePosition(fileRef, -(long)numBytesToPutBack, 0);		if (err == 0)		nominalLineLength = numBytesRead + 10;		buffer[numBytesRead] = 0;	if (numBytesReadPtr != NULL)		*numBytesReadPtr = numBytesRead;	return err;}/*	FullPathPointsToFile(fullPath)	Returns 1 if the path points to an existing file, 0 if it points to a folder or	does not point to anything.		fullPath may be a Macintosh or a Windows path.	This routine is typically used by a file-loader XOP when it decides if it has	enough information to load the file or needs to display an open file dialog.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intFullPathPointsToFile(const char* fullPath){	char nativePath[MAX_PATH_LEN+1];	int err;		if (err = GetNativePath(fullPath, nativePath))		return err;	#ifdef _MACINTOSH_	// [	{		CInfoPBRec pRec;		unsigned char temp[MAX_PATH_LEN+1];			/*	HR, 020805: It appears that the behavior of PBGetCatInfoSync has changed			in Carbon if you pass it an empty string. I think it used to return an			error, which is what I expected. Now it returns 0.		*/		if (*nativePath == 0)			return 0;		if (strlen(nativePath) > 255)			return 0;									// Because we use PBGetCatInfoSync which takes a Pascal string with can not exceed 255 characters.		CopyCStringToPascal(nativePath, temp);				MemClear(&pRec, sizeof(pRec));		pRec.hFileInfo.ioNamePtr = temp;		err = PBGetCatInfoSync(&pRec);		if (err != 0)			return 0;		if ((pRec.dirInfo.ioFlAttrib & 0x10) != 0)		// Points to a folder.			return 0;		return 1;	}	#endif				// _MACINTOSH_ ]	#ifdef _WINDOWS_	// [	{		unsigned long attributes;				attributes = GetFileAttributes(nativePath);		if (attributes == 0xFFFFFFFF)					// Error?			return 0;		if ((attributes & FILE_ATTRIBUTE_DIRECTORY) != 0)			return 0;									// Points to a folder.				return 1;	}	#endif				// _WINDOWS_ ]}/*	FullPathPointsToFolder(fullPath)	Returns true if the path points to an existing folder, false if it points to a file or	does not point to anything.		fullPath may be a Macintosh or a Windows path.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intFullPathPointsToFolder(const char* fullPath){	char nativePath[MAX_PATH_LEN+1];	int err;		if (err = GetNativePath(fullPath, nativePath))		return err;	#ifdef _MACINTOSH_	// [	{		CInfoPBRec pRec;		unsigned char temp[MAX_PATH_LEN+1];			/*	HR, 020805: It appears that the behavior of PBGetCatInfoSync has changed			in Carbon if you pass it an empty string. I think it used to return an			error, which is what I expected. Now it returns 0.		*/		if (*nativePath == 0)			return 0;			if (strlen(nativePath) > 255)			return 0;									// Because we use PBGetCatInfoSync which takes a Pascal string with can not exceed 255 characters.		CopyCStringToPascal(nativePath, temp);		MemClear(&pRec, sizeof(pRec));		pRec.hFileInfo.ioNamePtr = temp;		err = PBGetCatInfoSync(&pRec);		if (err != 0)			return 0;		if ((pRec.dirInfo.ioFlAttrib & 0x10) == 0)		// Points to a file.			return 0;		return 1;	}	#endif				// _MACINTOSH_ ]	#ifdef _WINDOWS_	// [	{		unsigned long attributes;				attributes = GetFileAttributes(nativePath);		if (attributes == 0xFFFFFFFF)					// Error?			return 0;		if ((attributes & FILE_ATTRIBUTE_DIRECTORY) == 0)			return 0;									// Points to a file.				return 1;	}	#endif				// _WINDOWS_ ]}/*	WinToMacPath(path)	This routine converts a Windows path into a Macintosh path by replacing	':\' with ':' and  '\' with ':'. HOWEVER, it does not change a UNC volume name.	Thus,		C:\A\B\C				=>		C:A:B:C		\\server\share\A\B\C	=>		\\server\share:A:B:C	The volume name is "\\server\share" whether the path is a Mac path or	a Windows path.		Also, leading periods are changed to colons. For example, "..\FolderA\FileB"	is changed to "::FolderA:FileB".		If the path is already a Mac path, it will do nothing.		NOTE:	The path may be shorter on output than in was on input			(':\' or '.\' changed to ':').				This routine is Asian-character-set aware.		Function result is 0 if OK or error code.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intWinToMacPath(char path[MAX_PATH_LEN+1]){	return CallBack1(WIN_TO_MAC_PATH, path);}/*	MacToWinPath(path)	This routine converts a Macintosh path into a Windows path by replacing	':' with ':\' at the start of a full path and replacing ':' with '\' elsewhere.	HOWEVER, it does not change a UNC volume name. Thus,		C:A:B:C					=>		C:\A\B\C		\\server\share:A:B:C	=>		\\server\share\A\B\C	The volume name is "\\server\share" whether the path is a Mac path or	a Windows path.	NOTE: If a Mac path contains a '\' character, the resulting path will		  not work as a Windows path. Therefore, '\' characters must not be		  used in Mac paths.		Also, leading colons are changed to periods. For example, "::FolderA:FileB"	is changed to "..\FolderA\FileB".		If the path is already a Windows path, it will do nothing.		NOTE:	The path may be longer on output than in was on input ('C:' changed to			'C:\' or ':' changed to '.\'). The buffer is assumed to be MAX_PATH_LEN+1			characters long. MacToWinPath will not overwrite the buffer. It will			generate an error if the output path can not fit in MAX_PATH_LEN characters.		Function result is 0 if OK or an error code (e.g., PATH_TOO_LONG).		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intMacToWinPath(char path[MAX_PATH_LEN+1]){	return CallBack1(MAC_TO_WIN_PATH, path);}/*	GetNativePath(filePathIn, filePathOut)		Call this to make sure that a file path uses the conventions regarding	colons and backslashes of the current platform.		It copies filePathIn to filePathOut. If filePathIn does not use the conventions	of the current platform, it converts filePathOut to use those conventions.		filePathOut can point to the same memory as filePathIn or it can	point to different memory.		filePathOut must be declared to hold MAX_PATH_LEN+1 characters.		Function result is 0 if OK or an error code (e.g., PATH_TOO_LONG).		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intGetNativePath(const char* filePathIn, char filePathOut[MAX_PATH_LEN+1]){	int err;		if (strlen(filePathIn) > MAX_PATH_LEN)		return PATH_TOO_LONG;			if (filePathOut != filePathIn)		strcpy(filePathOut, filePathIn);		#ifdef _MACINTOSH_		err = WinToMacPath(filePathOut);	#endif	#ifdef _WINDOWS_		err = MacToWinPath(filePathOut);	#endif	return err;}/*	EscapeBackslashesInUNCVolumeName(macFilePath)		This routine is used when we are generating a literal string containing a file path	that may refer to a Windows server. For a Windows server, the volume name is a	Universal Name Convention name, something like \\server\share. This is true even	if the path is a Macintosh path. If we are generating a command using this path,	as in the LoadWave dialog, we need to escape the backslashes because Igor interprets	backslashes as escape characters.		Returns the number of characters added to the string or -1 if the string is too long.	Note that macFilePath is assumed to be MAX_PATH_LEN characters long.		Added for XOP Toolkit 4.0B01, 991007. Works with any version of Igor.		Technical Note: This routine will not work on a UNC name that uses Asian	characters if the second byte of any character is equivalent to a backslash	character. This is because the strchr function below does not know about	Asian characters. I would be possible but difficult to fix this. The situation	should be very rare if it happens at all.*/intEscapeBackslashesInUNCVolumeName(char macFilePath[MAX_PATH_LEN+1]){		int maxCharsThatCanBeAdded;	char macFilePathIn[MAX_PATH_LEN+1];	char* pIn;	char* pOut;	char* pBackslash;	char backslashChar;	backslashChar = '\\';	if (macFilePath[0]!=backslashChar || macFilePath[1]!=backslashChar)		return 0;									// This is not a Windows server name.	maxCharsThatCanBeAdded = MAX_PATH_LEN - strlen(macFilePath);	if (maxCharsThatCanBeAdded < 3)		return -1;									// We need to add three backslashes.		strcpy(macFilePathIn, macFilePath);	macFilePath[2] = backslashChar;					// Add first extra backslash.	macFilePath[3] = backslashChar;					// Add second extra backslash.		pIn = &macFilePathIn[2];						// Points to the original input data.	pOut = &macFilePath[4];							// Points to the output data.	pBackslash = strchr(pIn, backslashChar);		// Points to the third backslash in the input data. NULL if there is no third backslash - this would be a bogus server name.	while(*pIn != 0) {		if (pIn == pBackslash)			*pOut++ = backslashChar;				// Add third extra backslash.		*pOut++ = *pIn++;			}	*pOut = 0;		return 3;}/*	GetDirectoryAndFileNameFromFullPath(fullFilePath, dirPath, fileName)	fullFilePath is a full path to a file. It may be a Macintosh path (using colons)	or a Windows path (using backslashes).		On output, dirPath is the full native path to the folder containing the file.	This path includes a trailing colon (Macintosh) or backslash (Windows).		On output, fileName contains just the name of the file.		Returns 0 if OK or an error code.		Note that GetDirectoryAndFileNameFromFullPath does not know or care if	the file exists or if the directories referenced in the input path exist.	It merely separates the file name part from the full path.		A simple implementation of this routine would merely search for colon or	backslash characters. However, this simple approach causes problems on Asian	systems that use two-byte characters. The problem is that the second byte of	a two-byte character may have the same code as a colon or backslash, causing	the simple implementation to mistakenly take it for a path separator.		GetDirectoryAndFileNameFromFullPath takes a more complex approach to avoid	this problem. To achieve this, the routine has to know the character encoding	governing the fullFilePath parameter. GetDirectoryAndFileNameFromFullPath assumes	that the system default character encoding governs the fullFilePath parameter.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intGetDirectoryAndFileNameFromFullPath(const char* fullFilePath, char dirPath[MAX_PATH_LEN+1], char fileName[MAX_FILENAME_LEN+1]){	return CallBack3(GET_DIR_AND_FILE_FROM_FULL_PATH, (void*)fullFilePath, dirPath, fileName);}/*	IsFullPathAndFileName(filePath)	filePath can be a Windows or Macintosh path.		Returns 1 if filePath has the syntax of a full path and file name, 0 if not.		Note that this does not tell you if filePath actually points to an existing file.	For that, use FullPathPointsToFile.*/static intIsFullPathAndFileName(const char* filePath){	char macFilePath[MAX_PATH_LEN+1];	const char* p;	int err;		// WinToMacPath does nothing if it is already a Macintosh path.	strcpy(macFilePath, filePath);	if (err = WinToMacPath(macFilePath))		return err;		if (*macFilePath == ':')						// Starts with colon ?		return 0;									// It's a partial path.		p = strrchr2(macFilePath, ':');					// Find last colon.	if (p == NULL)		return 0;									// Has no colon.			p += 1;											// Make sure it doesn't end with colon.	if (*p)											// Next char is not null ?		return 1;	return 0;}/*	GetLeafName(filePath, name)	filePath is either "", a valid file name or a valid path to a file.		name must be able to hold MAX_FILENAME_LEN+1 bytes.		Returns via name the leaf part of the path, if it is a path or the contents of filePath	if is not a path.		Returns 0 if OK or an error code.*/intGetLeafName(const char* filePath, char name[MAX_FILENAME_LEN+1]){	char macFilePath[MAX_PATH_LEN+1];	const char* p;	int err;		*name = 0;		// WinToMacPath does nothing if it is already a Macintosh path.	strcpy(macFilePath, filePath);	if (err = WinToMacPath(macFilePath))		return err;		p = strrchr2(macFilePath, ':');					// Find last colon.	if (p == NULL)									// Has no colon?		p = filePath;								// filePath is either "" or just a file name.	else		p += 1;										// filePath is either "" or a path and file name.		if (strlen(p) > MAX_FILENAME_LEN)		return STR_TOO_LONG;	strcpy(name, p);	return 0;}/*	GetFullPathFromSymbolicPathAndFilePath(symbolicPathName, filePath, fullFilePath)		symbolicPathName is the name of an Igor symbolic path or "" if no symbolic	path is to be used.		filePath is either a full path, a partial path, or a simple file name.	It may use Macintosh or Windows path conventions.		fullFilePath is an output and will contain the full path to the file referenced	by symbolicPathName and filePath. The returned path will use Macintosh path	conventions on Macintosh and Windows path conventions on Windows.		This routine is used by file loader XOPs to get a full path to a file based	on the typical inputs to a file loader, namely an optional Igor symbolic path	and an optional full or partial file path or file name.		The two most common cases are:		LoadWave <full path to file>		LoadWave/P=<symbolic path name> <file name>			where <file name> conotes a simple file name.		Less common cases that this routine also handles are:		LoadWave/P=<symbolic path name> <full path to file>		// Symbolic path is ignored.		LoadWave/P=<symbolic path name> <partial path to file>		In the following cases, the full path to the file can not be determined,	so GetFullPathFromSymbolicPathAndFilePath returns an error. This would cause	a file loader to display an open file dialog:		LoadWave <file name>		LoadWave <partial path to file>		filePath and fullFilePath may point to the same storage, in which case the	output string will overwrite the input string.		This routine does not check that the output path is valid or points to an existing	file. This makes the routine useable for applications in which you are creating the	file as well as applications in which you are reading the file. If you want to verify	that the output path points to an existing file, use the FullPathPointsToFile routine.		Returns 0 if it was able to create the full path or an error code if not.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intGetFullPathFromSymbolicPathAndFilePath(const char* symbolicPathName, const char filePath[MAX_PATH_LEN+1], char fullFilePath[MAX_PATH_LEN+1]){	char symbolicPathPath[MAX_PATH_LEN+1];	char filePath2[MAX_PATH_LEN+1];	int err;		if (err = GetNativePath(filePath, filePath2))		return err;	if (*symbolicPathName==0) {		strcpy(fullFilePath, filePath2);	}	else {		if (IsFullPathAndFileName(filePath2)) {		// HR, 020806: Used IsFullPathAndFileName instead of FullPathPointsToFile.			// Although we have a symbolic path, we don't use it because the input path was already a full path.			strcpy(fullFilePath, filePath2);		}		else {			if (err = GetPathInfo2(symbolicPathName, symbolicPathPath))		// symbolicPathPath is native.				return err;					if (err = ConcatenatePaths(symbolicPathPath, filePath2, fullFilePath))				return err;		}	}		// HR, 020806: Added this.	if (!IsFullPathAndFileName(fullFilePath))		return FILE_OPEN_ERROR;		return 0;}/*	ConcatenatePaths(pathIn1, nameOrPathIn2, pathOut[MAX_PATH_LEN+1])	Concatenates pathIn1 and nameOrPathIn2 into pathOut. pathOut will be	a native path. The input paths may use Macintosh or Windows conventions.		pathIn1 is a full path to a directory. It can end with zero or one separator.		nameOrPathIn2 is either a file name, a folder name or a partial path to a file	or folder. It can end with zero or one separator.		pathOut can point to the same memory as either of the input parameters.	The target file or folder does not need to already exist.		For pathIn1, any of the following are legal.		"hd:FolderA:FolderB"		"hd:FolderA:FolderB:"		"C:\FolderA\FolderB"		"C:\FolderA\FolderB\"		For nameOrPathIn2, any of the following are legal.		"FileA"		"FolderC"		":FolderC"		"\FolderC"		".FolderC"					// Legal in a Windows path only.		"::FolderC"		"\\FolderC"		"..FolderC"					// Legal in a Windows path only.		"FolderC:FileA"		"FolderC\FileA"		"\FolderC:FileA"		"\FolderC\FileA"		Here are some examples.		"hd:FolderA:FolderB:"				+	"FolderC"		=>		"hd:FolderA:FolderB:FolderC"		"hd:FolderA:FolderB:"				+	":FolderC"		=>		"hd:FolderA:FolderB:FolderC"		"hd:FolderA:FolderB:"				+	"::FolderC"		=>		"hd:FolderA:FolderC"		"C:\FolderA\FolderB\"				+	"FolderC"		=>		"C:\FolderA\FolderB\FolderC"		"C:\FolderA\FolderB\"				+	"\FolderC"		=>		"C:\FolderA\FolderB\FolderC"		"C:\FolderA\FolderB\"				+	"\\FolderC"		=>		"C:\FolderA\FolderC"		"\\server\share\FolderA\FolderB\"	+	"FolderC"		=>		"\\server\share\FolderA\FolderB\FolderC"		"\\server\share\FolderA\FolderB\"	+	"\FolderC"		=>		"\\server\share\FolderA\FolderB\FolderC"		"\\server\share\FolderA\FolderB\"	+	"\\FolderC"		=>		"\\server\share\FolderA\FolderC"		Multiple colons or backslashes in nameOrPathIn2 mean that we want to back up,	starting from the folder specified by pathIn1.		Returns 0 or error code. In case of error, the contents of pathOut is undefined.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intConcatenatePaths(const char* pathIn1, const char* nameOrPathIn2, char pathOut[MAX_PATH_LEN+1]){	return CallBack3(CONCATENATE_PATHS, (void*)pathIn1, (void*)nameOrPathIn2, (void*)pathOut);}#ifdef _WINDOWS_		// [static UINT APIENTRY	// Hook for open or save file dialogs.OpenOrSaveFileNameHook(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam){		HWND hMainDlg;		/*	Because we use the OFN_EXPLORER flag and we specify a hook function, Windows		creates a child dialog for us and the hdlg parameter to this hook is the child		dialog.	*/	hMainDlg = GetParent(hdlg);	if (hMainDlg == NULL)		return 0;	switch(uiMsg) {		case WM_INITDIALOG:			PositionWinDialogWindow(hMainDlg, NULL);			break;	}	return 0;			// Let default dialog box procedure process the message.}#endif					// _WINDOWS_ ]/*	XOPOpenFileDialog(prompt, fileFilterStr, fileIndexPtr, initialDir, filePath)	Displays the open file dialog.		Returns 0 if the user chooses a file or -1 if the user cancels or another	non-zero number in the event of an error. Returns the full path to the	file via filePath. In the event of a cancel, filePath is unmodified.	filePath is a native path (using colons on Macintosh, backslashes on Windows).		On Windows, prompt sets the dialog caption. On Macintosh, it sets a prompt	string in the dialog.		If fileFilterStr is "", then the open file dialog displays all types	of files, both on Macintosh and Windows. If fileFilterStr is not "",	it identifies the type of files to display.	Prior to Carbon, fileFilterStr was a concatenation of Macintosh file type	codes. For example, to display text files and Igor Text files, you would	pass "TEXTIGTX".		Now this parameter provides control over the Show popup menu which the	Macintosh Navigation Manager displays in the Open File dialog. As a consequence,	the fileFilterStr is now constructed differently. For example, the string		"Text Files:TEXT,IGTX:.txt,.itx;All Files:****:;"	results in two items in the Show popup menu. The first says "Text Files"	and displays any file whose Macintosh file type is TEXT or IGTX as well as any	file whose file name extension is ".txt" or ".itx". The second item says "All Files"	and displays all files.		For further details on the fileFilterStr on Macintosh, see the comments under	XOPNavOpenFileDialog in XOPSupportMac.c.		On Windows, fileFilterStr is constructed as for the lpstrFilter field of	the OPENFILENAME structure for the Windows GetOpenFileName routine. For	example, to allow the user to select text files and Igor Text files, use	"Text Files (*.txt)\0*.txt\0Igor Text Files (*.itx)\0*.itx\0All Files (*.*)\0*.*\0\0".	Note that the string ends with two null characters (\0\0).		Prior to Carbon, fileIndexPtr was ignored on Macintosh. However, now it	is used on Macintosh and Windows, as described in the next paragraph.		fileIndexPtr is ignored if it is NULL. If it is not NULL, then	*fileIndexPtr is the one-based index of the file type filter to be initially	selected. In the example given above, setting *fileIndexPtr to 2 would select	the Igor Text file filter on entry to the dialog. On exit from the dialog,	*fileIndexPtr is set to the index of the file filter string that the user last	selected.  		initialDir can be "" or it can point to a full path to a directory. It	determines the directory that will be initially displayed in the open file	dialog. If "", the directory will be the last directory that was seen	in the open or save file dialogs. If initialDir points to a valid path to a directory,	then this directory will be initially displayed in the dialog. On Macintosh,	initialDir is a Macintosh path. On Windows, it is a Windows path.		Returns via filePath the full path to the file that the user chose	or "" if the user cancelled. The path is a Macintosh path on Macintosh	and a Windows path on Windows. filePath must point to a buffer of	at least MAX_PATH_LEN+1 bytes.		On Windows, the initial value of filePath sets the initial contents of	the File Name edit control in the open file dialog. The following values	are valid:		""									If there is no initial file name		a file name		a full Mac or Win path to a file	Allowed as of XOP Toolkit 5.04		On Macintosh, the initial value of filePath is not currently used. It should be set	the same as for Windows because it may be used in the future.		In the event of an error other than a cancel, XOPOpenFileDialog displays	an error dialog. This should never or rarely happen.		WINDOWS NOTES	This routine requires Igor Pro 3.13 or later.		The dialog will appear in the upper left corner of the screen. This is	because Windows provides no straight-forward way to set the position of	the dialog.*/intXOPOpenFileDialog(	const char* prompt,	const char* fileFilterStr, int* fileIndexPtr,	const char* initialDir,	char filePath[MAX_PATH_LEN+1]){	#ifdef _MACINTOSH_		// [	{		FSSpec spec;		FSSpec initialDirSpec;		FSSpec* initialDirSpecPtr;		int err;				initialDirSpecPtr = NULL;		if (*initialDir != 0) {			unsigned char temp[256];			CopyCStringToPascal(initialDir, temp);			if (err = FSMakeFSSpec(0, 0, temp, &initialDirSpec)) {				IgorError("XOPOpenFileDialog FSMakeFSSpec", err);				return err;			}			initialDirSpecPtr = &initialDirSpec;		}				if (err = XOPNavOpenFileDialog(prompt, fileFilterStr, fileIndexPtr, initialDirSpecPtr, &spec)) {			if (err != -1)			// -1 is cancel				IgorError("XOPOpenFileDialog XOPNavOpenFileDialog", err);			return err;		}			if (err = GetFullMacPathToDirectory(spec.vRefNum, spec.parID, filePath, MAX_PATH_LEN)) {			IgorError("XOPOpenFileDialog GetFullMacPathToDirectory", err);			return err;				// Should never happen.		}					{			char fileName[MAX_FILENAME_LEN+1];			CopyPascalStringToC(spec.name, fileName);			if (strlen(filePath) + strlen(fileName) > MAX_PATH_LEN) {				IgorError("XOPOpenFileDialog", err);				return PATH_TOO_LONG;			}			strcat(filePath, fileName);		}				return 0;	}	#endif					// _MACINTOSH_ ]	#ifdef _WINDOWS_		// [	{		OPENFILENAME ofn;		char filePath2[MAX_PATH_LEN+1];		char initialDir2[MAX_PATH_LEN+1];				if (*fileFilterStr == 0)			fileFilterStr = "All Files (*.*)\0*.*\0\0";					if (*initialDir == 0) {			GetStandardFileWinPath(initialDir2);	// Get Igor's open file dialog directory.		}		else {			strcpy(initialDir2, initialDir);			SetStandardFileWinPath(initialDir);		// Sets initial directory for next open file dialog. This will be overridden below, but not if the user cancels.		}					/*	HR, 040928, XOP Toolkit 5.04			Previously this copied filePath to filePath2. This was correct because the filePath parameter			was supposed to be either "" or just the proposed file name. However, I incorrectly passed			a full path for the filePath parameter in all of the sample XOPs. This mistake undoubtedly			leaked into users' XOPs. Therefore I now allow filePath to be either "", just a file name,			or a full path.		*/		// strcpy(filePath2, filePath);				// HR, 010815: Previously filePath2 was set to "" which prevented the File Name item in the Windows Open File dialog from being preset as the comment above says it should be.		GetLeafName(filePath, filePath2);		MemClear(&ofn, sizeof(ofn));		ofn.lStructSize = sizeof(ofn);		ofn.hwndOwner = IgorClientHWND();		ofn.lpstrFile = filePath2;		ofn.nMaxFile = MAX_PATH_LEN+1;		ofn.lpstrFilter = fileFilterStr;		ofn.nFilterIndex = fileIndexPtr==NULL ? 1 : *fileIndexPtr;		ofn.lpstrTitle = prompt;		ofn.lpstrFileTitle = NULL;		ofn.lpstrInitialDir = initialDir2;		ofn.lpfnHook = OpenOrSaveFileNameHook;		// Needed to set position of the dialog. Otherwise, it is in top/left corner of screen.		ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;		ofn.Flags |= OFN_EXPLORER;		ofn.Flags |= OFN_ENABLEHOOK;				// Needed so that hook will be called.		ofn.Flags |= OFN_HIDEREADONLY;		ofn.Flags |= OFN_NOCHANGEDIR;				// Changing the current directory causes problems. e.g., if set to floppy disk and the floppy is removed, the system slows down.			if (GetOpenFileName(&ofn) == 0) {			int err;			err = CommDlgExtendedError();			// err will be zero if cancel.			if (err == 0)				return -1;			// We got an error other than cancel.			*filePath2 = 0;							// HR, 021114: Clear possible bad fields			*initialDir2 = 0;						// and try again.			if (GetOpenFileName(&ofn) != 0) {		// Succeeded this time?				err = 0;			}			else {				if (CommDlgExtendedError() == 0)					return -1;						// User canceled.								// Report the original error.				err = WindowsErrorToIgorError(err);				IgorError("XOPOpenFileDialog", err);				return err;			}		}				if (fileIndexPtr != NULL)			*fileIndexPtr = ofn.nFilterIndex;				strcpy(filePath, filePath2);		SetStandardFileWinPath(filePath);			// Update Igor's open file dialog directory.		return 0;	}	#endif					// _WINDOWS_ ]}/*	XOPSaveFileDialog(prompt, fileFilterStr, fileIndexPtr, initialDir, defaultExtensionStr, filePath)	Displays the save file dialog.		Returns 0 if the user provides a file name or -1 if the user cancels or another	non-zero number in the event of an error.		Returns the full path to the file via filePath. filePath is both an input and an	output as explained below. In the event of a cancel, filePath is unmodified.	filePath is a Macintosh path on Macintosh and a Windows path on Windows.		On Windows, prompt sets the dialog caption. On Macintosh, it sets a prompt	string in the dialog.		Prior to Carbon, the fileFilterStr was ignored on Macintosh.	You were instructed to pass "" in case it was used in a future version	of the XOP Toolkit. As of XOP Toolkit 4.0, this parameter is now used to	control the contents of the Format popup menu in the Save File dialog.		On Macintosh, if there is only one format in which you can save the file,	pass "" for fileFilterStr. This will cause the Format menu to be hidden.	If you can save the file in more than one format, pass a string like this:		"Plain Text:TEXT:.txt;Igor Text:IGTX:.itx;"			This would give you a Format menu like this:		Plain Text		Igor Text		For further details on the fileFilterStr on Macintosh, see the comments under	XOPNavSaveFileDialog in XOPMacSupport.c.		On Windows, fileFilterStr identifies the types of files to display and the types	of files that can be created. It is constructed as for the lpstrFilter	field of the OPENFILENAME structure for the Windows GetSaveFileName routine.	For example, to allow the user to save as a text file or as an Igor Text file,	use "Text Files (*.txt)\0*.txt\0Igor Text Files (*.itx)\0*.itx\0\0". Note that	the string ends with two null characters (\0\0). If fileFilterStr is "", this	behaves the same as "Text Files (*.txt)\0*.txt\0\0". 		Prior to Carbon, fileIndexPtr was ignored on Macintosh. However, now it	is used on Macintosh and Windows, as described in the next paragraph.	fileIndexPtr it is ignored if it is NULL. If it is not NULL, then *fileIndexPtr	is the one-based index of the file type filter to be initially selected.	In the example given above, setting *fileIndexPtr to 2 would select the Igor	Text file type on entry to the dialog. On exit from the dialog, *fileIndexPtr	is set to the index of the file type string that the user last selected.		initialDir can be "" or it can point to a full path to a directory. It	determines the directory that will be initially displayed in the save file	dialog. If "", the directory will be the last directory that was seen in the	open or save file dialogs. If initialDir points to a valid path to a directory,	then this directory will be initially displayed in the dialog. On Macintosh,	initialDir is a Macintosh path. On Windows, it is a Windows path. 		defaultExtensionStr is ignored on Macintosh. You must pass "" because this may be	used in a future version of the XOP Toolkit.		On Windows, defaultExtensionStr points to the extension to be added to the	file name if the user does not enter an extension. For example, pass "txt"	to have ".txt" appended if the user does not enter an extension. If you don't	want any extension to be added in this case, pass NULL.		Returns via filePath the full path to the file that the user chose	or "" if the user cancelled. The path is a Macintosh path on Macintosh	and a Windows path on Windows. filePath must point to a buffer of	at least MAX_PATH_LEN+1 bytes.		On Windows and Macintosh, the initial value of filePath sets the initial contents of	the File Name edit control in the save file dialog. The following values	are valid:		""									If there is no initial file name		a file name		a full Mac or Win path to a file	Allowed as of XOP Toolkit 5.04		In the event of an error other than a cancel, XOPSaveFileDialog displays	an error dialog. This should never or rarely happen.		WINDOWS NOTES	This routine requires Igor Pro 3.13 or later.		The dialog will appear in the upper left corner of the screen. This is	because Windows provides no straight-forward way to set the position of	the dialog.*/intXOPSaveFileDialog(	const char* prompt,	const char* fileFilterStr, int* fileIndexPtr,	const char* initialDir,	const char* defaultExtensionStr,	char filePath[MAX_PATH_LEN+1]){	#ifdef _MACINTOSH_		// [		#pragma unused(fileIndexPtr)		#pragma unused(defaultExtensionStr)			{		FSSpec spec;		FSSpec initialDirSpec;		FSSpec* initialDirSpecPtr;		char filePath2[MAX_PATH_LEN+1];		int err;				initialDirSpecPtr = NULL;		if (*initialDir != 0) {			unsigned char temp[256];			CopyCStringToPascal(initialDir, temp);			if (err = FSMakeFSSpec(0, 0, temp, &initialDirSpec)) {				IgorError("XOPSaveFileDialog FSMakeFSSpec", err);				return err;			}			initialDirSpecPtr = &initialDirSpec;		}				GetLeafName(filePath, filePath2);		// HR, 040928, XOP Toolkit 5.04: This can now be a full path.		if (err = XOPNavSaveFileDialog(prompt, fileFilterStr, fileIndexPtr, filePath2, initialDirSpecPtr, &spec)) {			if (err != -1)			// -1 is cancel				IgorError("XOPSaveFileDialog XOPNavSaveFileDialog", err);			return err;		}			if (err = GetFullMacPathToDirectory(spec.vRefNum, spec.parID, filePath, MAX_PATH_LEN)) {			IgorError("XOPSaveFileDialog GetFullMacPathToDirectory", err);			return err;				// Should never happen.		}					{			char fileName[MAX_FILENAME_LEN+1];			CopyPascalStringToC(spec.name, fileName);			if (strlen(filePath) + strlen(fileName) > MAX_PATH_LEN) {				IgorError("XOPSaveFileDialog", err);				return PATH_TOO_LONG;			}			strcat(filePath, fileName);		}		return 0;	}	#endif					// _MACINTOSH_ ]	#ifdef _WINDOWS_		// [	{		OPENFILENAME ofn;		char filePath2[MAX_PATH_LEN+1];		char initialDir2[MAX_PATH_LEN+1];				if (*fileFilterStr == 0)			fileFilterStr = "Text Files (*.txt)\0*.txt\0\0";					if (*initialDir == 0) {			GetStandardFileWinPath(initialDir2);	// Get Igor's save file dialog directory.		}		else {			strcpy(initialDir2, initialDir);			SetStandardFileWinPath(initialDir);		// Sets initial directory for next save file dialog. This will be overridden below, but not if the user cancels.		}					/*	HR, 040928, XOP Toolkit 5.04			Previously this copied filePath to filePath2. This was correct because the filePath parameter			was supposed to be either "" or just the proposed file name. However, I incorrectly passed			a full path for the filePath parameter in all of the sample XOPs. This mistake undoubtedly			leaked into users' XOPs. Therefore I now allow filePath to be either "", just a file name,			or a full path.		*/		// strcpy(filePath2, filePath);				// HR, 010815: Previously filePath2 was set to "" which prevented the File Name item in the Windows Open File dialog from being preset as the comment above says it should be.		GetLeafName(filePath, filePath2);		MemClear(&ofn, sizeof(ofn));		ofn.lStructSize = sizeof(ofn);		ofn.hwndOwner = IgorClientHWND();		ofn.lpstrFile = filePath2;		ofn.nMaxFile = MAX_PATH_LEN+1;		ofn.lpstrFilter = fileFilterStr;		ofn.nFilterIndex = fileIndexPtr==NULL ? 1 : *fileIndexPtr;		ofn.lpstrDefExt = defaultExtensionStr;		ofn.lpstrTitle = prompt;		ofn.lpstrFileTitle = NULL;		ofn.lpstrInitialDir = initialDir2;		ofn.lpfnHook = OpenOrSaveFileNameHook;		// Needed to set position of the dialog. Otherwise, it is in top/left corner of screen.		ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;		ofn.Flags |= OFN_EXPLORER;		ofn.Flags |= OFN_ENABLEHOOK;				// Needed so that hook will be called.		ofn.Flags |= OFN_HIDEREADONLY;		ofn.Flags |= OFN_NOCHANGEDIR;				// Changing the current directory causes problems. e.g., if set to floppy disk and the floppy is removed, the system slows down.		if (GetSaveFileName(&ofn) == 0) {			int err;			err = CommDlgExtendedError();			// err will be zero if cancel.			if (err == 0)				return -1;			// We got an error other than cancel.			*filePath2 = 0;							// HR, 021114: Clear possible bad fields			*initialDir2 = 0;						// and try again.			if (GetSaveFileName(&ofn) != 0) {		// Succeeded this time?				err = 0;			}			else {				if (CommDlgExtendedError() == 0)					return -1;						// User canceled.								// Report the original error.				err = WindowsErrorToIgorError(err);				IgorError("XOPSaveFileDialog", err);				return err;			}		}				if (fileIndexPtr != NULL)			*fileIndexPtr = ofn.nFilterIndex;				strcpy(filePath, filePath2);		SetStandardFileWinPath(filePath);			// Update Igor's open file dialog directory.		return 0;	}	#endif					// _WINDOWS_ ]}/*	FileLoaderGetOperationFlags(additionalFlagsChars, flagsPtr, baseName, wdRefNumPtr)	As of XOP Toolkit 4.0 (Carbon), FileLoaderGetOperationFlags is no longer supported.	Use FileLoaderGetOperationFlags2 instead.*//*	FileLoaderGetOperationFlags2(additionalFlagsChars, flagsPtr, baseName, symbolicPathName)	FileLoaderGetOperationFlags2 parses any standard file loader flags in the command line.	It sets the integer referred to by flagsPtr using one bit for each flag as defined in	XOP.h.		If there is a /A=baseName flag it returns the base wave name via baseName.	If there is a /P=path flag it returns the path's name via symbolicPathName.		For the standard flags, as defined in XOP.h, additionalFlagsChars should be "".	If your file loader supports additional flags that are merely of the form:			/X		or 	/X=<boolean>	then you can pass additional characters in additionalFlagsChars.		For example, if you pass "XYZ" then FileLoaderGetOperationFlags2 will accept		/X or /X=<boolean>		(sets bit (FILE_LOADER_LAST_FLAG<<1) in *flagsPtr)	and		/Y or /Y=<boolean>		(sets bit (FILE_LOADER_LAST_FLAG<<2) in *flagsPtr)	and		/Z or /Z=<boolean>		(sets bit (FILE_LOADER_LAST_FLAG<<3) in *flagsPtr)		If your file loader supports more complex additional flags, you will need to	create your own augmented version of this routine in your own file.	It returns 0 if OK or an error code otherwise.		Added in Igor Pro 3.13. If you call this when running with an earlier version,	it will return IGOR_OBSOLETE.*/intFileLoaderGetOperationFlags2(const char* additionalFlagsChars, long *flagsPtr, char *baseName, char symbolicPathName[MAX_OBJ_NAME+1]){	char allowedFlagsChars[256];	int flag;	int flagMask;	char fileDirPath[MAX_PATH_LEN+1];	int result;			*flagsPtr = 0;	baseName[0] = '\0';							// Assume no /A= flag.	*symbolicPathName = 0;						// Means no path.		strcpy(allowedFlagsChars, "PQODCIAN");		// These are the standard flags as defined in XOP.h.	strcat(allowedFlagsChars, additionalFlagsChars);	while (flag = GetFlag(allowedFlagsChars)) {		if (flag < 0)			return(BADFLG);					switch(flag) {			case 'P':							// /P means symbolic path coming.				if (GetSymb() != '=')					return NOEQUALS;				if (result = GetName(symbolicPathName))					return EXPECTED_NAME;				if (*symbolicPathName == 0)					break;						// Treat /P=$"" as a NOP.				if (result = GetPathInfo2(symbolicPathName, fileDirPath))					return result;				// Path does not exist.				*flagsPtr |= FILE_LOADER_PATH;				break;			case 'Q':							// /Q[=q] means quiet -- no messages in history.				if (result = GetTrueOrFalseFlag(FILE_LOADER_QUIET, flagsPtr))					return result;				break;			case 'O':							// /O[=o] means overwrite waves.				if (result = GetTrueOrFalseFlag(FILE_LOADER_OVERWRITE, flagsPtr))					return result;				break;			case 'D':							// /D[=d] means make double precision waves.				if (result = GetTrueOrFalseFlag(FILE_LOADER_DOUBLE_PRECISION, flagsPtr))					return result;				break;			case 'C':							// /C[=c] means make complex waves.				if (result = GetTrueOrFalseFlag(FILE_LOADER_COMPLEX, flagsPtr))					return result;				break;			case 'I':							// /I[=i] means interactive (open dialog).				if (result = GetTrueOrFalseFlag(FILE_LOADER_INTERACTIVE, flagsPtr))					return result;				break;			case 'A':							// /A means autoname waves, don't overwrite.			case 'N':							// /N means autoname waves, do overwrite.				*flagsPtr |= FILE_LOADER_AUTONAME;				if (NextSymb() == '=') {		// Have /A=baseName ?					GetSymb();					// Suck up =					if (GetName(baseName))						return(EXPECTED_NAME);				}				if (flag == 'N')					*flagsPtr |= FILE_LOADER_OVERWRITE;		// /N is equivalent to /A/O.				break;						default:				flagMask = FILE_LOADER_LAST_FLAG << (strchr(additionalFlagsChars, flag) - additionalFlagsChars + 1);				if (result = GetTrueOrFalseFlag(flagMask, flagsPtr))					return result;				break;		}	}	return 0;}/*	FileLoaderMakeWave(column, waveName, numPoints, fileLoaderFlags, waveHandlePtr)	FileLoaderMakeWave makes a wave with numPoints points and numeric type as specified	by fileLoaderFlags.		The function result is 0 or an error code.	It returns a handle to the wave via waveHandlePtr.		fileLoaderFlags is interpreted using the standard file loader flag bit definitions.	See XOP.h.		NOTE:	In the event of a name conflict, FileLoaderMakeWave can change the contents of			waveName. waveName must be able to hold MAX_OBJ_NAME characters.*/intFileLoaderMakeWave(long column, char *waveName, long numPoints, int fileLoaderFlags, waveHndl *waveHandlePtr){		int type, overwrite;	char newName[MAX_OBJ_NAME+2];	char temp[128];	int result;	type = (fileLoaderFlags & FILE_LOADER_DOUBLE_PRECISION) ? NT_FP64:NT_FP32;	overwrite = fileLoaderFlags & FILE_LOADER_OVERWRITE;	result = MakeWave(waveHandlePtr,waveName,numPoints,type,overwrite);		/*	If error other than NOMEM or NAME_WAV_CONFLICT, it's probably a conflict		with an operation or function. Try again using a different wave name.	*/	if (result && result != NOMEM && result != NAME_WAV_CONFLICT) {		sprintf(newName, "X_%s", waveName);		SanitizeWaveName(newName, column);		if (!(fileLoaderFlags&FILE_LOADER_QUIET)) {			sprintf(temp, "Name conflict making %s, name changed to %s\015", waveName, newName);			XOPNotice(temp);		}		result = MakeWave(waveHandlePtr,newName,numPoints,type,overwrite);		if (result == 0)			strcpy(waveName, newName);	}	if (result && !(fileLoaderFlags&FILE_LOADER_QUIET)) {		sprintf(temp, "Error making %s\015", waveName);		XOPNotice(temp);	}	return(result);}/*	DoSetFileLoaderOutputVariables(runningInUserFunction, fileName, numWavesLoaded, waveNames)	See SetFileLoaderOutputVariables and SetRuntimeFileLoaderOutputVariables for details.		Returns 0 or error code.*/static intDoSetFileLoaderOutputVariables(int runningInUserFunction, const char* fileName, int numWavesLoaded, const char* waveNames){	const char* fullPathPtr;	const char* fileNamePtr;	int result;		fullPathPtr = fileName;								// Assume full path.		// Find start of the leaf name.	fileNamePtr = strrchr2(fileName, ':');	if (fileNamePtr!=NULL && fileNamePtr[1]!='\\') {	// Found colon other than the one in "C:\" ?		fileNamePtr += 1;								// Point to character after the last colon.	}	else {		fileNamePtr = strrchr2(fileName, '\\');		if (fileNamePtr != NULL) {			fileNamePtr += 1;							// Point to character after the last backslash.		}		else {			// No colon and no backslash.			fileNamePtr = fileName;			fullPathPtr = "";							// No full path.		}	}		// HR, 981103: Added setting of S_path for XOP Toolkit 3.1.	// For backward compatibility, we skip creating S_path if the XOP did not pass in a full path.	if (*fullPathPtr != 0) {							// We have a full path?		char dirPath[MAX_PATH_LEN+1];		char fileName2[MAX_FILENAME_LEN+1];				if (GetDirectoryAndFileNameFromFullPath(fullPathPtr, dirPath, fileName2) == 0) {			if (FullPathPointsToFolder(dirPath)) {				WinToMacPath(dirPath);				if (runningInUserFunction) {					if (result = SetOperationStrVar("S_path", dirPath))						return result;				}				else {					if (result = SetIgorStringVar("S_path", dirPath, 0))						return result;				}			}		}	}		if (runningInUserFunction) {		if (result = SetOperationStrVar("S_fileName", fileNamePtr))			return result;				if (result = SetOperationStrVar("S_waveNames", waveNames))			return result;				if (result = SetOperationNumVar("V_flag", numWavesLoaded))			return result;		}	else {		if (result = SetIgorStringVar("S_fileName", fileNamePtr, 0))			return result;				if (result = SetIgorStringVar("S_waveNames", waveNames, 0))			return result;				if (result = SetIgorIntVar("V_flag", numWavesLoaded, 0))			return result;	}		return 0;}/*	SetFileLoaderOutputVariables(fileName, numWavesLoaded, waveNames)	This should be called at the end of a file load to set the "standard"	file loader output globals:		S_fileName			The name of the file loaded.		S_path				The full path to the folder containing the file. See note below.		V_flag				The number of waves loaded.		S_waveNames			Semicolon-separate list of wave names							(e.g. "wave0;wave1;wave2;").								fileName can be either just the file name (e.g., "Data File") or a full	path including a file name (e.g., "hd:Data Folder:Data File"). If it is a	full path, it can use either Macintosh or Windows syntax.		If fileName is a full path, SetFileLoaderOutputVariables stores the path to the	folder containing the file in S_path and stores the simple file name in	S_fileName. In this case, the path uses Macintosh path syntax and includes	a trailing colon. 		If fileName is a simple file name, SetFileLoaderOutputVariables does not	set or create S_path and stores the simple file name in S_fileName.		The setting of S_path was added in XOP Toolkit 3.1. New or updated XOPs	should pass the full path to SetFileLoaderOutputVariables so that S_path	will be set to a meaningful value.		Returns 0 or error code.*/intSetFileLoaderOutputVariables(const char* fileName, int numWavesLoaded, const char* waveNames){	return DoSetFileLoaderOutputVariables(0, fileName, numWavesLoaded, waveNames);}/*	SetFileLoaderOperationOutputVariables(runningInUserFunction, fileName, numWavesLoaded, waveNames)	This function does the same thing as SetFileLoaderOutputVariables except that,	when runningInUserFunction is true, it sets local variables in the user function.		This function is intended to be used when you are implementing an external operation	using Operation Handler. When you register your operation via RegisterOperation,	you must specify that your operation sets the numeric variable V_flag and the	string variables S_fileName, S_path, and S_waveNames. See SimpleLoadWave for an	example.	See discussion of SetFileLoaderOutputVariables for further details.		Returns 0 or error code.			Added in Igor Pro 5.0 but works with any version. If you call this when running with	an earlier version, it acts just like SetFileLoaderOutputVariables regardless of the	value of runningInUserFunction.*/intSetFileLoaderOperationOutputVariables(int runningInUserFunction, const char* fileName, int numWavesLoaded, const char* waveNames){	if (IgorVersion() < 500)		runningInUserFunction = 0;		return DoSetFileLoaderOutputVariables(runningInUserFunction, fileName, numWavesLoaded, waveNames);}	/*	PrepareLoadIgorData(ldiPtr, refNumPtr, topFIHPtr)	This routine is for use by the WaveMetrics Data Browser only.		ldiPtr is a pointer to a LoadDataInfo structure. This structure is private to WaveMetrics.	topFIHPtr is a pointer to a LoadFileInfo structure handle. This structure is private to WaveMetrics.			Added in Igor Pro 3.0. If you call this when running with an earlier version,	you will receive the IGOR_OBSOLETE error code as the function result.*/intPrepareLoadIgorData(struct LoadDataInfo* ldiPtr, long* refNumPtr, struct LoadFileInfo*** topFIHPtr){	return(CallBack3(PREPARE_LOAD_IGOR_DATA, ldiPtr, refNumPtr, topFIHPtr));}	/*	LoadIgorData(ldiPtr, refNum, topFIH, destDataFolderH)	This routine is for use by the WaveMetrics Data Browser only.		ldiPtr is a pointer to a LoadDataInfo structure. This structure is private to WaveMetrics.	topFIH is a handle to a LoadFileInfo structure. This structure is private to WaveMetrics.			Added in Igor Pro 3.0. If you call this when running with an earlier version,	you will receive the IGOR_OBSOLETE error code as the function result.*/intLoadIgorData(struct LoadDataInfo* ldiPtr, long refNum, struct LoadFileInfo** topFIH, DataFolderHandle destDataFolderH){	return(CallBack4(DO_LOAD_IGOR_DATA, ldiPtr, (void*)refNum, topFIH, destDataFolderH));}	/*	EndLoadIgorData(ldiPtr, refNum, topFIH)	This routine is for use by the WaveMetrics Data Browser only.		ldiPtr is a pointer to a LoadDataInfo structure. This structure is private to WaveMetrics.	topFIH is a handle to a LoadFileInfo structure. This structure is private to WaveMetrics.			Added in Igor Pro 3.0. If you call this when running with an earlier version,	you will receive the IGOR_OBSOLETE error code as the function result.*/intEndLoadIgorData(struct LoadDataInfo* ldiPtr, long refNum, struct LoadFileInfo** topFIH){	return(CallBack3(END_LOAD_IGOR_DATA, ldiPtr, (void*)refNum, topFIH));}/*	SaveIgorData(sdiPtr, topDataFolderH)	This routine is for use by the WaveMetrics Data Browser only.		sdiPtr is a pointer to a SaveDataInfo structure. This structure is private to WaveMetrics.			Added in Igor Pro 5.0. If you call this when running with an earlier version,	you will receive the IGOR_OBSOLETE error code as the function result.*/intSaveIgorData(struct SaveDataInfo* sdiPtr, DataFolderHandle topDataFolderH){	return(CallBack2(DO_SAVE_IGOR_DATA, sdiPtr, topDataFolderH));}#include "XOPStructureAlignmentReset.h"	// Reset structure alignment to default.