/*	XOPWaveAccess.c		Routines for Igor XOPs that provide access to multi-dimensional waves.*/#include "XOPStandardHeaders.h"			// Include ANSI headers, Mac headers, IgorXOP.h, XOP.h and XOPSupport.h#include "XOPStructureAlignmentTwoByte.h"	// All structures passed between Igor and XOP are two-byte aligned./*	WARNING	WARNING	WARNING	WARNING	What follows are the structures used by Igor to store waves in memory.	The routines in this file use these structures to provide quick access	to Igor wave info and data.		YOU SHOULD NOT USE THESE STRUCTURES DIRECTLY.		If you use these structures directly, your XOP will fail if we ever change	the structure of waves in Igor. Instead, use the accessor functions provided	in this file. These functions take care of backward and forward compatibility	for you so that your XOP will work with older versions of Igor and with	future versions of Igor.		A BIT OF HISTORY		There have been 3 main wave structures.	The first was used in Igor 1.0 through 1.1. It is not supported here.	The second was used in Igor 1.2 through Igor Pro 2.0 and is supported.	The third was introduced with Igor Pro 3.0 and is supported.		The version field is in the same place in version 2 and version 3 wave structures.	It is 26 bytes from the start of the structure. This lets us test the version field	to determine which kind of structure we are dealing with.*//*	This is the version 2 wave structure, introduced in Igor 1.2	and used through Igor Pro 2.0x.	The value in the version field is 0.*/#define kWaveStruct2Version 0struct WaveStruct2 {	short type;						// see IgorMath.h for types	struct WaveStruct2 **next;		// link to next wave in linked list	char bname[18+2];				// name of wave	short version;					// 0 indicates version 2 wave structure.	short srcFldr;					// zero or working directory number of source folder	Handle fileName;				// used only if wave originated from binary file	// units - compound units are for the dim and distant future	char dUnits[4];					// natural data units go here - null if none	char xUnits[4];					// natural x-axis units go here - null if none	long numPoints;					// number of data points in wave	short aModified;				// Bit flag. Set if horiz axis modified. Cleared when graphs and whatnot are updated.	double hsA,hsB;					// X value for point p = hsA*p + hsB	short wModified;				// True if the wave has been modified since the last update of graphs and whatnot.	short swModified;				// True if the wave has been modified since the last save to disk.	short fsValid;					// TRUE if full scale values have meaning	double topFullScale,			// the max full scale value for wave		   botFullScale;			// the min full scale value for wave		   	char wUnused[16];				// reserved for future use	unsigned long modDate;			// datetime of last modification	Handle userComment;				// NULL if no wave note	float wData[4];					// The start of the array of waveform data.									// The 4 floats allocated here just serve as padding									// for the extra point generated by a DFT. (2 doubles max)									// Actual data type and length depend on wave};typedef struct WaveStruct2 WaveStruct2;typedef WaveStruct2 *WavePtr2;typedef WavePtr2 *WaveHandle2;/*	This is the version 3 wave structure, introduced in Igor Pro 3.0	to support text waves and multi-dimensional waves.	The value in the version field is 1.*/#define MAXDIMS1 4					// Maximum dimensions in wave struct version 3.#define kWaveStruct3Version 1struct WaveStruct3 {	struct WaveStruct3 **next;		// link to next wave in linked list	unsigned long creatDate;		// datetime of creation	unsigned long modDate;			// datetime of last modification	long numPoints;					// total number of points in all dimensions	short type;						// see IgorMath.h for types -- if zero then strings*/	short dLock;					// bit 0= data locked, others reserved	char reserved1[6];				// fill to force specific offset for next item	short version;					// 1 indicates version 3 wave structure.	char bname[MAX_WAVE_NAME+1];	// name of wave	long reserved2;					// padding to maintain 64 bit alignment		struct DataFolder **dFolder;	// data folder where this list of waves is stored	/*	**	Dimensioning info. [0] == rows, [1] == cols etc	*/	long nDim[MAXDIMS1];			// number of of items in a dimension -- 0 means no data	double sfA[MAXDIMS1];			// X value for row = sfA[0]*p + sfB	double sfB[MAXDIMS1];	/*	**	SI units	*/	char dataUnits[3+1];			// natural data units go here - null if none	char dimUnits[MAXDIMS1][3+1];	// natural dimension units go here - null if none	short fsValid;					// TRUE if full scale values have meaning	short reserved3;				// padding to maintain 64 bit alignment	double topFullScale,			// the max full scale value for wave		   botFullScale;			// the min full scale value for wave	/*	**	Extended units. These optional items are an extension of the units field.	**	For now they can be used to write out the full name of the units but someday,	**	with appropriate escape codes, could be used for compound units.	*/	Handle dataEUnits;	Handle dimEUnits[MAXDIMS1];	/*	**	Dimension labels. Contains user set names for each row, column	**	or layer. Each may be NULL or may contain fewer labels than there	**	are rows, columns or layers. Each handle contains an array of	**	cstrings with each given 32 chars (MAX_OBJ_NAME+1). Thus the number	**	of labels is GetHandleSize(h)/(MAX_OBJ_NAME+1).	*/	Handle dimLabels[MAXDIMS1];		Handle userComment;				// NULL if no wave note		long whUnused[16];				// for future expansion (compound units, properties, image data)	/*	**	The following stuff is considered private to Igor.	*/	short aModified;				// Bit flag. Set if horiz axis modified. Cleared when graphs and whatnot are updated.	short wModified;				// True if the wave has been modified since the last update of graphs and whatnot.	short swModified;				// True if the wave has been modified since the last save to disk.		char useBits;					// bit field for runtime use only -- save as zero	char kindBits;					// allow categorizing wave	struct FreeEquation **feqn;		// if not NULL then wave is bound to equation	long depID;						// dependency directory ID		short modCount;					// Added for Igor Pro 4.0D09. Used by Data Browser to tell when a wave is changed. This field is incremented each time a wave is modified.	short srcFldr;					// zero or working directory number of source folder	Handle fileName;				// used only if wave originated from binary file		long **sIndices;				// handle to array of indices into data if strings (totpts)	float wData[1];					// The start of the array of data.};typedef struct WaveStruct3 WaveStruct3;typedef WaveStruct3 *WavePtr3;typedef WavePtr3 *WaveHandle3;#define WAVE_VERSION(wavH) ((*(WaveHandle2)wavH)->version)/*	*** Wave Access Routines *** *//*	WaveHandleModified(wavH)	WaveHandleModified() does a callBack to Igor to notify it that the specified	wave has been modified.*/voidWaveHandleModified(waveHndl wavH){	CallBack1(WAVEMODIFIED, wavH);}/*	WaveHandlesModified(waves, numWaves, start, end)	WaveHandlesModified() does a callBack to Igor to notify it that specified waves have been	modified. It also allows you to specify a range of a wave that was modified if only	part of it was changed.		waves is an array of wave handles	numWaves is the number of wave handles in the array	start and end are arrays of start and end points for the modified range of each wave.	If start is NIL, the range start for each wave is the start of that wave.	If end is NIL, the range end for each wave is the end of that wave.		Currently, Igor updates the entire wave for each wave in the waves array.	A future version of Igor will update only the part specified by the start and end	range arrays.*/voidWaveHandlesModified(	waveHndl waves[],				/* array of wave handles */	int numWaves,					/* number of wave handles in waves[] */	long start[],					/* array of starting point numbers for modified range or NIL */	long end[])						/* array of ending point numbers for modified range or NIL */{	CallBack4(WAVESMODIFIED, waves, (void *)numWaves, start, end);}/*	WaveModified(waveName)	WaveModified() does a callBack to Igor to notify it that the specified wave	has been modified. It ASSUMES that waveName is the name of a valid wave.*/voidWaveModified(const char *waveName){	CallBack1(WAVEMODIFIED, FetchWave(waveName));}/*	FetchWave(waveName)	FetchWave returns a handle to the data structure for the specified wave	or NIL if the wave does not exist.*/waveHndlFetchWave(const char *waveName){	waveHndl wavH;		wavH = (waveHndl)CallBack1(FETCHWAVE, (void*)waveName);	return(wavH);}/*	FetchWaveFromDataFolder(dataFolderH, waveName)	FetchWaveFromDataFolder returns a handle to the data structure for the	specified wave in the specified data folder or NIL if the wave does not exist.	This routine is often called after getting a wave name and data folder from	the command line using GetDataFolderAndName.	If dataFolderH is NIL, it uses the current data folder.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/waveHndlFetchWaveFromDataFolder(DataFolderHandle dataFolderH, const char* waveName){	waveHndl wavH;		if (igorVersion < 300)			/* Data folders were added in Igor Pro 3.0. */		wavH = FetchWave(waveName);	else		wavH = (waveHndl)CallBack2(FETCHWAVE_FROM_DATAFOLDER, dataFolderH, (void*)waveName);	return(wavH);}/*	WaveType(wavH)	Returns wave type which is:		NT_FP32, NT_FP64 for single or double precision floating point		NT_I8, NT_I16, NT_I32 for 8, 16 or 32 bit signed integer	This is ORed with NT_COMPLEX if the wave is complex	and ORed with NT_UNSIGNED if the wave is unsigned integer.		In Igor Pro 3.0 or later, the wave type can also be TEXT_WAVE_TYPE	which indicates a text wave. Text waves can not be complex.		Note: Future version may support other number types.		  Always check the wave type to make sure it is a type you can handle.*/intWaveType(waveHndl wavH){	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return (*(WaveHandle2)wavH)->type;			break;				case kWaveStruct3Version:			return (*(WaveHandle3)wavH)->type;			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack1(WAVETYPE, wavH));			break;	}}/*	WavePoints(wavH)	Returns number of points in wave.		In Igor Pro 3.0, this can be a multi-dimensional wave. In this case,	WavePoints returns the total number of points in all dimensions.*/longWavePoints(waveHndl wavH){	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return (*(WaveHandle2)wavH)->numPoints;			break;				case kWaveStruct3Version:			return (*(WaveHandle3)wavH)->numPoints;			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack1(WAVEPOINTS, wavH));			break;	}}/*	WaveName(wavH, namePtr)	Returns name of the wave via namePtr.*/voidWaveName(waveHndl wavH, char *namePtr){	CallBack2(WAVENAME, wavH, namePtr);}/*	WaveData(wavH)	Returns pointer to start of wave's data.		WARNING: Data can move if the wavH is not locked.			 Unless you have locked the wave handle, the address returned by WaveData			 is invalid as soon as you do any call that can scramble the heap.		WARNING: Do not use WaveData to access a text wave.		In Igor Pro 3.0 or later, the wave can be multi-dimensional.		Although WaveData returns the correct address for all supported versions of	Igor (supported == 1.2 or later), new XOPs should use the more modern	multi-dimensional wave access routines MDAccessNumericWaveData,	MDGetNumericWavePointValue and MDSetNumericWavePointValue instead of WaveData.*/void *WaveData(waveHndl wavH){	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return &(*(WaveHandle2)wavH)->wData;			break;				case kWaveStruct3Version:			return &(*(WaveHandle3)wavH)->wData;			break;				default:		/* Future version of Igor with a different wave structure. */			return((void *)CallBack1(WAVEDATA, wavH));			break;	}}/*	WaveScaling(wavH, hsAPtr, hsBPtr, topPtr, botPtr)	Returns the wave's X and Y scaling information.		hsA and hsB define the transformation from point number to X value where	  X value = hsA*Point# + hsB.	  	top and bottom are the values that the user entered for the wave's Y Full Scale.	If both are zero, there is no Y Full Scale for this wave.		In Igor Pro 3.0 or later, the wave can be multi-dimensional. See MDGetWaveScaling.*/voidWaveScaling(waveHndl wavH, double *hsAPtr, double *hsBPtr, double *topPtr, double *botPtr){	CallBack5(WAVESCALING, wavH, hsAPtr, hsBPtr, topPtr, botPtr);}/*	SetWaveScaling(wavH, hsAPtr, hsBPtr, topPtr, botPtr)	Sets the wave's X and Y scaling information.	If hsAPtr and/or hsBPtr are NIL, does not set X scaling.	If topPtr and/or botPtr are NIL, does not set Y scaling.		In Igor Pro 3.0 or later, the wave can be multi-dimensional. See MDSetWaveScaling.*/voidSetWaveScaling(waveHndl wavH, double *hsAPtr, double *hsBPtr, double *topPtr, double *botPtr){	CallBack5(SETWAVESCALING, wavH, hsAPtr, hsBPtr, topPtr, botPtr);}/*	WaveUnits(wavH, xUnits, dataUnits)	Returns the wave's X and data units string.		In Igor Pro 3.0, the number of characters allowed was increased from	3 to 49 (MAX_UNIT_CHARS). For backward compatibility, WaveUnits will return	no more than 3 characters (plus the null terminator). To get the full units and	to access units for higher dimensions, new XOPs should use MDGetWaveUnits instead	of WaveUnits.*/voidWaveUnits(waveHndl wavH, char *xUnits, char *dataUnits){	CallBack3(WAVEUNITS, wavH, xUnits, dataUnits);}/*	SetWaveUnits(wavH, xUnits, dataUnits)	Sets the wave's X and data units string.	If xUnits is NIL, does not set X units.	If dataUnits is NIL, does not set data units.	When running with Igor Pro 3.0 or later, units can be up to 49 (MAX_UNIT_CHARS)	characters long. In earlier versions of Igor, units are limited to 3 characters.	You can pass a longer units string but only the first 3 characters will be used.		To access units for higher dimensions, use MDSetWaveUnits instead	of SetWaveUnits.*/voidSetWaveUnits(waveHndl wavH, const char *xUnits, const char *dataUnits){	CallBack3(SETWAVEUNITS, wavH, (void*)xUnits, (void*)dataUnits);}/*	WaveNote(wavH)	Returns handle to wave's note text or NIL if wave has no note.		NOTE: you should not modify or dispose this handle. Use SetWaveNote() to change note.*/HandleWaveNote(waveHndl wavH){	return((Handle)CallBack1(WAVENOTE, wavH));}/*	SetWaveNote(wavH, noteHandle)	Sets wave's note text.	noteHandle is handle to text or NIL if you want to kill wave's note.		NOTE: once you pass the noteHandle to Igor, don't modify or dispose of it.*/voidSetWaveNote(waveHndl wavH, Handle noteHandle){	CallBack2(SETWAVENOTE, wavH, noteHandle);}/*	WaveModDate(wavH)	Returns wave modification date. This is an unsigned long in Macintosh	date/time format, namely the number of seconds since midnight, January 1, 1904.		The main use for this is to allow an XOP to check if a particular wave has been	changed. For example, an XOP that displays a wave can check the wave's mod date	in the XOP's idle routine. If the date has changed since the last time the	XOP updated its display, it can update the display again.		Modification date tracking was added to Igor in Igor 1.2. If a wave	is loaded from a file created by an older version of Igor, the mod date field	will be zero and this routine will return zero.		This routine was added in XOP Toolkit release 3.0 but works with all supported	versions (>= 1.24) of Igor.*/unsigned longWaveModDate(waveHndl wavH){	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return (*(WaveHandle2)wavH)->modDate;			break;				case kWaveStruct3Version:			return (*(WaveHandle3)wavH)->modDate;			break;				default:		/* Future version of Igor with a different wave structure. */			return((unsigned long)CallBack1(WAVEMODDATE, wavH));			break;	}}/*	WaveLock(wavH)	Returns the lock state of the wave.		A return value of 0 signifies that the wave is not locked.		A return value of 1 signifies that the wave is locked. In that case, you should	not kill the wave or modify it in any way.		Added in Igor Pro 5.0. When running with an earlier version, WaveLock always	returns 0.*/intWaveLock(waveHndl wavH){	if (igorVersion < 500)		return 0;	return CallBack1(WAVELOCK, wavH);}/*	SetWaveLock(wavH, lockState)	Sets wave's lock state.		If lockState is 0, the wave will be unlocked. If it is 1, the wave will be locked.		All other bits are reserved.		Returns the previous state of the wave lock setting.		Added in Igor Pro 5.0. When running with an earlier version, SetWaveLock is a	NOP and always returns 0.*/intSetWaveLock(waveHndl wavH, int lockState){	if (igorVersion < 500)		return 0;	return CallBack2(SETWAVELOCK, wavH, (void*)lockState);}/*	WaveModState(wavH)	Returns the truth that the wave has been modified since the last save to disk.	This routine works with all versions of Igor.*/intWaveModState(waveHndl wavH){	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return (*(WaveHandle2)wavH)->swModified;			break;				case kWaveStruct3Version:			return (*(WaveHandle3)wavH)->swModified;			break;				default:		/* Future version of Igor with a different wave structure. */			return CallBack1(WAVEMODSTATE, wavH);			break;	}}/*	WaveModCount(wavH)	Returns a value that can be used to tell if a wave has been changed between	one call to WaveModCount and another. This function was created so that the	Igor Data Browser could tell when a wave was changed. Previously, the Data	Browser used the WaveModDate function, but that function can not identify	changes that happen closer than 1 second apart.		The exact value returned by WaveModCount has no significance. The only valid	use for it is to compare the values returned by two calls to WaveModCount. If	they are the different, the wave was changed in the interim.		Example:		waveModCount1 = WaveModCount(wavH);		. . .		waveModCount2 = WaveModCount(wavH);		if (waveModCount2 != waveModCount1)			// Wave has changed.	The wave mod count was added in Igor Pro 4.0D08. If you are running with	an earlier version of Igor, this function will always return 0.*/intWaveModCount(waveHndl wavH){	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return 0;			break;				case kWaveStruct3Version:			return (*(WaveHandle3)wavH)->modCount;			break;				default:		/* Future version of Igor with a different wave structure. */			return CallBack1(WAVEMODCOUNT, wavH);			break;	}}/*	GetWavesInfo(waves, numWaves, waveTypes, waveLengths, waveStates, wavePtrs)	Given an array of wave handles (in waves) and the number of wave handles in the array	(in numWaves), returns the type, length, handle state and pointer to start of data	for each wave (via waveTypes[], waveLengths[], waveStates[] and wavePtrs[]).		If waveStates IS NOT NULL, it puts the current state of the wave handle in the waveStates	array, moves the handle to the top of the heap and locks it. If waveStates IS, it does	none of this.		Returns length of longest wave.*/longGetWavesInfo(	waveHndl waves[],				/* array of wave handles */	int numWaves,					/* number of wave handles in waves[] */	int waveTypes[],				/* on output, array of wave numeric types */	long wavePoints[],				/* on output, array of wave lengths */	int waveStates[],				/* on output, array of wave handle hStates */	void *wavePtrs[])				/* on output, array of pointers to start of wave data */{	long numPoints;					/* length of longest wave */	int w;	waveHndl wavH;		/* init output arrays */	MemClear(waveTypes, (long)(numWaves*sizeof(int)));	MemClear(wavePoints, (long)(numWaves*sizeof(long)));	if (waveStates != NULL)		MemClear(waveStates, (long)(numWaves*sizeof(int)));	MemClear(wavePtrs, (long)(numWaves*sizeof(void *)));		/* find wave types and length of longest wave */	numPoints = 0;	for (w = 0; w < numWaves; w++) {		wavH = waves[w];		if (wavH) {									/* skip NIL wave handles */			waveTypes[w] = WaveType(wavH);			/* get wave's numeric type */			wavePoints[w] = WavePoints(wavH);		/* get wave's length */			if (wavePoints[w] > numPoints)				numPoints = wavePoints[w];			/* remember longest wave length */			if (waveStates != NULL) {				/* save state (locked/unlocked) of handle */				waveStates[w] = HGetState(wavH);				MoveHHi(wavH);				HLock(wavH);			}			wavePtrs[w] = WaveData(wavH);			/* get pointer to start of wave's data */		}	}		return(numPoints);}/*	SetWavesStates(waves, numWaves, waveStates)	Given an array of wave handles (in waves) and the number of wave handles in the array	(in numWaves), sets the handle state for each wave according to states in waveStates[].*/voidSetWavesStates(	waveHndl waves[],				/* array of wave handles */	int numWaves,					/* number of wave handles in waves[] */	int waveStates[])				/* on output, array of wave handle hStates */{	int w;		for (w = 0; w < numWaves; w++)		if (waves[w])				/* skip NIL wave handles */			HSetState(waves[w], waveStates[w]);}/*	MakeWave(wavHPtr,waveName,numPoints,type,overwrite)	Tries to make wave with specified name, number of points, numeric type.	Returns error code or 0 if wave was made.*/intMakeWave(waveHndl *wavHPtr, const char *waveName, long numPoints, int type, int overwrite){	int type2;		*wavHPtr = NIL;	if (igorVersion < 300) {			/* Multi-dimensional and text waves were added in Igor Pro 3.0. */		type2 = type & ~NT_CMPLX;				if (type2==TEXT_WAVE_TYPE)			return IGOR_OBSOLETE;		/* This version of Igor does not support text waves. */					if (igorVersion < 200) {		/* Integer waves were added in Igor Pro 2.0. */			if (type2!=NT_FP32 && type2!=NT_FP64)				return IGOR_OBSOLETE;	/* This version of Igor does not support integer waves. */		}	}	return(CallBack5(MAKEWAVE, wavHPtr, (void*)waveName, (void *)numPoints, (void *)type, (void *)overwrite));}/*	ChangeWave(wavH, numPoints, type)	Changes wave length to specified number of points and numeric type.	Returns error code or 0 if OK.*/intChangeWave(waveHndl wavH, long numPoints, int type){	int type2;		if (igorVersion < 300) {			/* Multi-dimensional and text waves were added in Igor Pro 3.0. */		type2 = type & ~NT_CMPLX;				if (type2==TEXT_WAVE_TYPE)			return IGOR_OBSOLETE;		/* This version of Igor does not support text waves. */					if (igorVersion < 200) {		/* Integer waves were added in Igor Pro 2.0. */			if (type2!=NT_FP32 && type2!=NT_FP64)				return IGOR_OBSOLETE;	/* This version of Igor does not support integer waves. */		}	}	return(CallBack3(CHANGEWAVE,wavH,(void *)numPoints,(void *)type));}/*	KillWave(wavH)	Kills wave.	Returns error code or 0 if OK.		NOTE: if wave is in use, returns error code and wave is not killed.*/intKillWave(waveHndl wavH){	return(CallBack1(KILLWAVE, wavH));}/*	*** Multi-dimension Wave Access Routines *** *//*	MDMakeWave(wavHPtr,waveName,dataFolderH,dimensionSizes,type,overwrite)	Tries to make wave with specified name and type in the specified data folder.		If dataFolderH is NIL, it uses the current data folder.		For each dimension, dimensionSizes[i] specifies the number of points	in that dimension. For a wave of dimension n, i goes from 0 to n-1.		NOTE: dimensionSizes[n] must be zero. This is how Igor determines		  how many dimensions the wave is to have.	Returns error code or 0 if wave was made.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).	However, you will get an error if you try to make a type of wave not	supported in the running version of Igor.		Multi-dimensional, unsigned integer and text waves require Igor Pro 3.0 or later.		Signed integer waves require Igor Pro 2.0 or later.*/intMDMakeWave(waveHndl *wavHPtr, const char *waveName, DataFolderHandle dataFolderH, long dimensionSizes[MAX_DIMENSIONS+1], int type, int overwrite){	*wavHPtr = NIL;		if (igorVersion < 300) {			/* Multi-dimensional and text waves were added in Igor Pro 3.0. */		if (dimensionSizes[1] != 0)			return IGOR_OBSOLETE;		/* This version of Igor does not support multi-dimensional waves. */		if (type==TEXT_WAVE_TYPE || (type&NT_UNSIGNED)!=0)			return IGOR_OBSOLETE;		/* This version of Igor does not support text or unsigned waves. */		if (igorVersion < 200) {			if ((type&NT_I8)!=0 || (type&NT_I16)!=0 || (type&NT_I32)!=0)				return IGOR_OBSOLETE;	/* This version of Igor does not support integer waves. */		}		return MakeWave(wavHPtr, waveName, dimensionSizes[0], type, overwrite);	}	return(CallBack6(MD_MAKEWAVE,wavHPtr, (void*)waveName,dataFolderH, dimensionSizes, (void *)type, (void *)overwrite));}/*	MDGetWaveDimensions(wavH, numDimensionsPtr, dimensionSizes)	Returns number of used dimensions in wave via numDimensionsPtr	and the number of points in each used dimension via dimensionSizes.	If you only want o know the number of dimensions, you can pass NIL for dimensionSizes.		NOTE: dimensionSizes (if not NIL) should have room for MAX_DIMENSIONS+1 values.	For an n dimensional wave, MDGetWaveDimensions sets dimensionSizes[0..n-1] 	to the number of elements in the corresponding dimension and sets	dimensionSizes[n..MAX_DIMENSIONS] to zero, indicating that they are unused	dimensions. This guarantees that there will always be an element containing	zero in the dimensionSizes array.		The function result is 0 or an Igor error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDGetWaveDimensions(waveHndl wavH, long* numDimensionsPtr, long dimensionSizes[MAX_DIMENSIONS+1]){	long dimSize;	int i;		if (dimensionSizes != NIL)		MemClear(dimensionSizes, (MAX_DIMENSIONS+1)*sizeof(long));		/* All unused dimensions are zeroed. */	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			*numDimensionsPtr = 1;			if (dimensionSizes != NIL)				dimensionSizes[0] = (*(WaveHandle2)wavH)->numPoints;			return 0;			break;		case kWaveStruct3Version:			*numDimensionsPtr = 0;			for(i=0; i<MAXDIMS1; i++) {				dimSize = (*(WaveHandle3)wavH)->nDim[i];				if (dimSize==0)					break;				*numDimensionsPtr += 1;				if (dimensionSizes!=NIL)					dimensionSizes[i] = dimSize;			}			return 0;			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack3(MD_GETWAVEDIMENSIONS, wavH, numDimensionsPtr, dimensionSizes));			break;	}}/*	MDChangeWave(wavH, type, dimensionSizes)	Changes one or more of the following:		the wave's data type		the number of dimensions in the wave		the number of points in one or more dimensions		type is one of the following:		-1 for no change in data type.				NT_FP32, NT_FP64 for single or double precision floating point		NT_I8, NT_I16, NT_I32 for 8, 16 or 32 bit signed integer.		These may be ORed with NT_COMPLEX to make the wave complex		and ORed with NT_UNSIGNED to make the wave unsigned integer.			TEXT_WAVE_TYPE.	However converting a text wave to numeric or vice versa is currently not	supported and will result in an error.		dimensionSizes[i] contains the desired number of points for dimension i.	For n dimensions, dimensionSizes[n] must be zero. Then the size of each	dimension is set by dimensionSizes[0..n-1].		If dimensionSizes[i] == -1, then the size of dimension i will be unchanged.		Returns 0 or an error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDChangeWave(waveHndl wavH, int type, long dimensionSizes[MAX_DIMENSIONS+1]){	if (igorVersion < 300) {			/* Multi-dimensional and text waves were added in Igor Pro 3.0. */		if (dimensionSizes[1] != 0)			return IGOR_OBSOLETE;		/* This version of Igor does not support multi-dimensional waves. */		if (dimensionSizes[0] < 2)			return BADNPNTS;			/* Pre 3.0, waves were required to have at least two points. */		if (type==TEXT_WAVE_TYPE || (type&NT_UNSIGNED)!=0)			return IGOR_OBSOLETE;		/* This version of Igor does not support text or unsigned waves. */		if (igorVersion < 200) {			if ((type&NT_I8)!=0 || (type&NT_I16)!=0 || (type&NT_I32)!=0)				return IGOR_OBSOLETE;	/* This version of Igor does not support integer waves. */		}		return ChangeWave(wavH, dimensionSizes[0], type);	}	return(CallBack3(MD_CHANGEWAVE, wavH, (void *)type, dimensionSizes));}/*	MDChangeWave2(wavH, type, dimensionSizes, mode)	This is the same as MDChangeWave except for the added mode parameter.		mode = 0:	Does a normal redimension.		mode = 1:	Changes the wave's dimensions without changing the wave data.				This is useful, for example, when you have a 2D wave				consisting of 5 rows and 3 columns which you want to treat				as a 2D wave consisting of 3 rows and 5 columns.		mode = 2:	Changes the wave data from big-endian to little-endian				or vice versa. This is useful when you have loaded data				from a file that uses a byte ordering different from that				of the platform on which you are running.		Returns 0 or an error code.		Added in Igor Pro 5.04B06. If mode is zero it will work with Igor Pro 3.0	or later. If mode is non-zero and the version of Igor is earlier than	5.04B06 it will return IGOR_OBSOLETE and do nothing.*/intMDChangeWave2(waveHndl wavH, int type, long dimensionSizes[MAX_DIMENSIONS+1], int mode){	if (mode == 0)		return CallBack3(MD_CHANGEWAVE, wavH, (void *)type, dimensionSizes);		return CallBack4(MD_CHANGEWAVE2, wavH, (void *)type, dimensionSizes, (void *)mode);}/*	MDGetWaveScaling(wavH, dimension, sfAPtr, sfBPtr)	Returns the dimension scaling values or the full scale values for the wave.	If dimension is -1, it returns the full scale values. Otherwise, it returns the dimension	scaling.		For dimension d, the scaled index of point p is:	  scaled index = sfA[d]*p + sfB[d].		If dimension is -1, this gets the wave's data full scale setting instead of	dimension scaling. *sfAPtr points to the top full scale value and *sfBPtr	points to the bottom full scale value.		The function result is 0 or an Igor error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDGetWaveScaling(waveHndl wavH, int dimension, double* sfAPtr, double* sfBPtr){	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			if (dimension<-1 || dimension>0)				return BAD_DIMENSION_NUMBER;			if (dimension == -1) {				if ((*(WaveHandle2)wavH)->fsValid) {	// HR, 050203, XOP Toolkit 5.04: Added this test. It should have been there all along.					*sfAPtr = (*(WaveHandle2)wavH)->topFullScale;					*sfBPtr = (*(WaveHandle2)wavH)->botFullScale;				}				else {					*sfAPtr = 0;					*sfBPtr = 0;				}			}			else {				*sfAPtr = (*(WaveHandle2)wavH)->hsA;				*sfBPtr = (*(WaveHandle2)wavH)->hsB;			}			return 0;			break;		case kWaveStruct3Version:			if (dimension<-1 || dimension>3)				return BAD_DIMENSION_NUMBER;			if (dimension == -1) {				if ((*(WaveHandle3)wavH)->fsValid) {	// HR, 050203, XOP Toolkit 5.04: Added this test. It should have been there all along.					*sfAPtr = (*(WaveHandle3)wavH)->topFullScale;					*sfBPtr = (*(WaveHandle3)wavH)->botFullScale;				}				else {					*sfAPtr = 0;					*sfBPtr = 0;				}			}			else {				*sfAPtr = (*(WaveHandle3)wavH)->sfA[dimension];				*sfBPtr = (*(WaveHandle3)wavH)->sfB[dimension];			}			return 0;			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack3(MD_GETWAVESCALING, wavH, sfAPtr, sfBPtr));			break;	}}/*	MDSetWaveScaling(wavH, dimension, sfAPtr, sfBPtr)	Sets the dimension scaling values or the full scale values for the wave.	If dimension is -1, it sets the full scale values. *sfAPtr is the top full	scale value and *sfBPtr is the bottom full scale value.		If dimension is 0 or greater, it sets the dimension scaling.	For dimension d, the scaled index of point p is:	  scaled index = sfA[d]*p + sfB[d].	The sfA value can never be set to zero. If you pass 0.0 for sfA, this routine	will use 1.0 instead.		If dimension is -1, this sets the wave's data full scale setting instead of	dimension scaling. *sfAPtr points to the top full scale value and *sfBPtr	points to the bottom full scale value.		The function result is 0 or an Igor error code.		Requires Igor Pro 3.0 or later.*/intMDSetWaveScaling(waveHndl wavH, int dimension, double* sfAPtr, double* sfBPtr){	/*	HR, 031112, XOP Toolkit 5.00:		This routine previously set wave fields directly instead of calling		back to Igor. This was not sufficient because Igor internally sets		other flags in addition to the wave fields. So now it always does		a callback to Igor.	*/	return(CallBack4(MD_SETWAVESCALING, wavH, (void*)dimension, sfAPtr, sfBPtr));}/*	MDGetWaveUnits(wavH, dimension, units)	Returns the units string for the specified dimension in the wave via units.		To get the data units (as opposed to dimension units), pass -1 for dimension.		In Igor Pro 3.0 or later, units can be up to 49 (MAX_UNIT_CHARS) characters. In	earlier versions, units were limited to 3 characters.			The function result is 0 or an Igor error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDGetWaveUnits(waveHndl wavH, int dimension, char units[MAX_UNIT_CHARS+1]){	char dummyUnits[MAX_UNIT_CHARS+1];		*units = 0;		switch (WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			/* Earlier than Igor Pro 3.0? */			switch (dimension) {				case -1:									/* Data units. */					WaveUnits(wavH, dummyUnits, units);					break;				case 0:										/* X units. */					WaveUnits(wavH, units, dummyUnits);					break;			}			return 0;			break;				case kWaveStruct3Version:		default:			return(CallBack3(MD_GETWAVEUNITS, wavH, (void*)dimension, units));			break;	}}/*	MDSetWaveUnits(wavH, int dimension, units[MAX_UNIT_CHARS+1])	Sets the units string for the specified dimension.		To set the data units (as opposed to dimension units), pass -1 for dimension.		In Igor Pro 3.0 or later, units can be up to 49 (MAX_UNIT_CHARS) characters. In	earlier versions, units were limited to 3 characters. In either case, if the	string you pass is too long, Igor will store a truncated version of it. 		The function result is 0 or an Igor error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDSetWaveUnits(waveHndl wavH, int dimension, char units[MAX_UNIT_CHARS+1]){	switch (WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			/* Earlier than Igor Pro 3.0? */			switch (dimension) {				case -1:									/* Data units. */					SetWaveUnits(wavH, NIL, units);					break;				case 0:										/* X units. */					SetWaveUnits(wavH, units, NIL);					break;			}			return 0;			break;				case kWaveStruct3Version:		default:			return(CallBack3(MD_SETWAVEUNITS, wavH, (void*)dimension, units));			break;	}}/*	MDGetDimensionLabel(wavH, dimension, element, label)	Returns the label for the specified element of the specified dimension via label.		If element is -1, this specifies a label for the entire dimension.	If element is between 0 to n-1, where n is the size of the dimension,	then element specifies a label for that element of the dimension only.		label should have room for MAX_DIM_LABEL_CHARS+1 bytes.	At present, Igor Pro truncates dimension labels at 31 characters.	A future version may increase this.			The function result is 0 or an Igor error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).	However, for versions prior to 3.0, it will always return NIL (no labels).*/intMDGetDimensionLabel(waveHndl wavH, int dimension, long element, char label[MAX_DIM_LABEL_CHARS+1]){	switch (WAVE_VERSION(wavH)) {		case kWaveStruct2Version:					/* Earlier than Igor Pro 3.0? */			*label = 0;								/* There were no dimension labels. */			return 0;			break;				case kWaveStruct3Version:		default:			return(CallBack4(MD_GETDIMLABELS, wavH, (void*)dimension, (void*)element, label));			break;	}}/*	MDSetDimensionLabel(wavH, dimension, element, label)	Sets the label for the specified element of the specified dimension via label.		If element is -1, this specifies a label for the entire dimension.	If element is between 0 to n-1, where n is the size of the dimension,	then element specifies a label for that element of the dimension only.		At present, Igor Pro truncates dimension labels at 31 characters.	A future version may increase this.			The function result is 0 or an Igor error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).	However, for versions prior to 3.0, this routine is a no-op since there	were no dimension labels prior to Igor Pro 3.0.*/intMDSetDimensionLabel(waveHndl wavH, int dimension, long element, char label[MAX_DIM_LABEL_CHARS+1]){	switch (WAVE_VERSION(wavH)) {		case kWaveStruct2Version:								/* Earlier than Igor Pro 3.0? */			return 0;											/* Has no dimension labels. */			break;				case kWaveStruct3Version:		default:			return(CallBack4(MD_SETDIMLABELS, wavH, (void*)dimension, (void*)element, label));			break;	}}/*	MDAccessNumericWaveData(wavH, accessMode, dataOffsetPtr)		MDAccessNumericWaveData provides access to the data for numeric waves.		wavH is the wave handle containing the data you want to access.		accessMode is a code that tells Igor how you plan to access the wave data	and is used for a future compatibility check. At present, there is only one	accessMode. You should use the symbol kMDWaveAccessMode0 for the accessMode parameter.		On output, if there is no error, *dataOffsetPtr contains the offset in bytes	from the start of the wave handle to the data.		MDAccessNumericWaveData returns 0 or an error code.		If it returns a non-zero error code, you should not attempt to access	the wave data but merely return the error code to Igor.		At present, there is only one case in which MDAccessNumericWaveData will return an	error code. This is if the wave is a text wave.		It is possible that a future version of Igor Pro will store wave data in	a different way, such that the current method of accessing wave data will no	longer work. If your XOP ever runs with such a future Igor, MDAccessNumericWaveData	will return an error code indicating the incompatibility. Your XOP will refrain	from attempting to access the wave data and return the error code to Igor.	This will prevent a crash and indicate the nature of the problem to the user.		Numeric wave data is stored contiguously in the wave handle in one of the	supported data types (NT_I8, NT_I16, NT_I32, NT_FP32, NT_FP64). These types	will be ORed with NT_CMPLX if the wave is complex and ORed with NT_UNSIGNED if	the wave is unsigned integer.		To access the a particular point, you need to know the number of data points in each	dimension. To find this, you must call MDGetWaveDimensions. This returns the number	of used dimensions in the wave and an array of dimension lengths. The dimension lengths	are interpreted as follows:		dimensionSizes[0]		number of rows in a column		dimensionSizes[1]		number of columns in a layer		dimensionSizes[2]		number of layers in a chunk		dimensionSizes[3]		number of chunks in the wave		The data is stored in row/column/layer/chunk order. This means that,	as you step linearly through memory one point at a time, you first pass the	value for each row in the first column. At the end of the first column,	you reach the start of the second column. After you have passed the data for	each column in the first layer, you reach the data for the first column	in the second layer. After you have passed the data for each layer, you	reach the data for the first layer of the second chunk. And so on.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDAccessNumericWaveData(waveHndl wavH, int accessMode, long* dataOffsetPtr){	if (accessMode!=kMDWaveAccessMode0) {		/* Call back to Igor if this is an unknown (future) access mode. */		if (WAVE_VERSION(wavH)==kWaveStruct2Version)			/* Earlier than Igor Pro 3.0? */			return IGOR_OBSOLETE;		return(CallBack3(MD_ACCESSNUMERICWAVEDATA, wavH, (void*)accessMode, dataOffsetPtr));	}		switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			*dataOffsetPtr = offsetof(WaveStruct2, wData);			return 0;			break;		case kWaveStruct3Version:			if ((*(WaveHandle3)wavH)->type == TEXT_WAVE_TYPE)				return NUMERIC_ACCESS_ON_TEXT_WAVE;			*dataOffsetPtr = offsetof(WaveStruct3, wData);			return 0;			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack3(MD_ACCESSNUMERICWAVEDATA, wavH, (void*)accessMode, dataOffsetPtr));			break;	}}/*	MDPointIndex1(wavH1, indices[MAX_DIMENSIONS], indexPtr)		For version 1 waves, returns a linear index number to access the point	indicated by the indices.		NOTE: This routine ignores indices for dimensions that do not exist in the wave.*/static intMDPointIndex1(WaveHandle3 wavH1, long indices[MAX_DIMENSIONS], long* indexPtr){	WavePtr3 wp= *wavH1;		/* DEREFERENCE */	long p;	long dimtot= 1;	long dimSize;	int i;		*indexPtr = 0;	for(i=0; i<MAXDIMS1; i++) {		dimSize = wp->nDim[i];		if (dimSize == 0)			break;							/* We've done all used dimensions. */		p = indices[i];		if (p<0 || p>=dimSize)			return MD_WAVE_BAD_INDEX;		if (dimSize != 0) {			*indexPtr += p*dimtot;			dimtot *= dimSize;		}	}	return 0;		}/*	FetchNumericValue(type, dataStartPtr, index, value)	type is an Igor numeric type.		dataStartPtr points to the start of the data of the specified type.		WARNING: dataStartPtr may point into a possibly unlocked handle.			 Therefore, this routine must not cause the heap to scramble.		index is the "point number" of the point of interest, considering	the data as one long vector.*/intFetchNumericValue(int type, const char* dataStartPtr, long index, double value[2]){	int isComplex;	double* dp;	float* fp;	long* lp;	unsigned long* ulp;	short* sp;	unsigned short* usp;	signed char* cp;	unsigned char* ucp;	isComplex = type & NT_CMPLX;	if (isComplex)		index *= 2;	type &= ~NT_CMPLX;		switch (type) {		case NT_FP64:			dp = (double*)dataStartPtr + index;			value[0] = *dp++;			if (isComplex)				value[1] = *dp;			break;			case NT_FP32:			fp = (float*)dataStartPtr + index;			value[0] = *fp++;			if (isComplex)				value[1] = *fp;			break;			case NT_I32:			lp = (long*)dataStartPtr + index;			value[0] = *lp++;			if (isComplex)				value[1] = *lp;			break;			case NT_I32 | NT_UNSIGNED:			ulp = (unsigned long*)dataStartPtr + index;			value[0] = *ulp++;			if (isComplex)				value[1] = *ulp;			break;			case NT_I16:			sp = (short*)dataStartPtr + index;			value[0] = *sp++;			if (isComplex)				value[1] = *sp;			break;			case NT_I16 | NT_UNSIGNED:			usp = (unsigned short*)dataStartPtr + index;			value[0] = *usp++;			if (isComplex)				value[1] = *usp;			break;			case NT_I8:			cp = (signed char*)dataStartPtr + index;			value[0] = *cp++;			if (isComplex)				value[1] = *cp;			break;			case NT_I8 | NT_UNSIGNED:			ucp = (unsigned char*)dataStartPtr + index;			value[0] = *ucp++;			if (isComplex)				value[1] = *ucp;			break;				case TEXT_WAVE_TYPE:			return NUMERIC_ACCESS_ON_TEXT_WAVE;					default:			return WAVE_TYPE_INCONSISTENT;		/* Should never happen. */	}		return 0;}/*	MDGetNumericWavePointValue(wavH, indices, value)		Returns via value the value of a particular point in the specified wave.	The value returned is always double precision floating point, regardless	of the precision of the wave.		indices is an array of dimension indices. For example, for a 3D wave,		indices[0] should contain the row number		indices[1] should contain the column number		indices[2] should contain the layer number		NOTE: This routine ignores indices for dimensions that do not exist in the wave.		The real part of the value of specified point is returned in value[0].	If the wave is complex, the imaginary part of the value of specified point	is returned in value[1]. If the wave is not complex, value[1] is undefined.		The function result is 0 or an error code.	Currently the only error code returned is MD_WAVE_BAD_INDEX, indicating	that you have passed invalid indices. Future versions of Igor may return	other error codes. If you receive an error, just return it to Igor so	that it will be reported to the user.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDGetNumericWavePointValue(waveHndl wavH, long indices[MAX_DIMENSIONS], double value[2]){	long index;	int result;		switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			index = indices[0];			return FetchNumericValue((*(WaveHandle2)wavH)->type, (char*)(*(WaveHandle2)wavH)->wData, index, value);			break;				case kWaveStruct3Version:			if (result = MDPointIndex1((WaveHandle3)wavH, indices, &index))				return result;			return FetchNumericValue((*(WaveHandle3)wavH)->type, (char*)(*(WaveHandle3)wavH)->wData, index, value);			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack3(MD_GETWAVEPOINTVALUE, wavH, indices, value));			break;	}}/*	StoreNumericValue(type, dataStartPtr, index, value)	type is an Igor numeric type.		dataStartPtr points to the start of the data of the specified type.		WARNING: dataStartPtr may point into a possibly unlocked handle.			 Therefore, this routine must not cause the heap to scramble.		index is the "point number" of the point of interest, considering	the data as one long vector.*/intStoreNumericValue(int type, char* dataStartPtr, long index, double value[2]){	int isComplex;	double* dp;	float* fp;	long* lp;	unsigned long* ulp;	short* sp;	unsigned short* usp;	signed char* cp;	unsigned char* ucp;	isComplex = type & NT_CMPLX;	if (isComplex)		index *= 2;	type &= ~NT_CMPLX;		switch (type) {		case NT_FP64:			dp = (double*)dataStartPtr + index;			*dp++ = value[0];			if (isComplex)				*dp = value[1];			break;			case NT_FP32:			fp = (float*)dataStartPtr + index;			*fp++ = value[0];			if (isComplex)				*fp = value[1];			break;			case NT_I32:			lp = (long*)dataStartPtr + index;			*lp++ = value[0];			if (isComplex)				*lp = value[1];			break;			case NT_I32 | NT_UNSIGNED:			ulp = (unsigned long*)dataStartPtr + index;			*ulp++ = value[0];			if (isComplex)				*ulp = value[1];			break;			case NT_I16:			sp = (short*)dataStartPtr + index;			*sp++ = value[0];			if (isComplex)				*sp = value[1];			break;			case NT_I16 | NT_UNSIGNED:			usp = (unsigned short*)dataStartPtr + index;			*usp++ = value[0];			if (isComplex)				*usp = value[1];			break;			case NT_I8:			cp = (signed char*)dataStartPtr + index;			*cp++ = value[0];			if (isComplex)				*cp = value[1];			break;			case NT_I8 | NT_UNSIGNED:			ucp = (unsigned char*)dataStartPtr + index;			*ucp++ = value[0];			if (isComplex)				*ucp = value[1];			break;				case TEXT_WAVE_TYPE:			return NUMERIC_ACCESS_ON_TEXT_WAVE;				default:			return WAVE_TYPE_INCONSISTENT;		/* Should never happen. */	}		return 0;}/*	MDSetNumericWavePointValue(wavH, indices, value)		Sets the value of a particular point in the specified wave.	The value that you supply is always double precision floating point,	regardless of the precision of the wave.		indices is an array of dimension indices. For example, for a 3D wave,		indices[0] should contain the row number		indices[1] should contain the column number		indices[2] should contain the layer number		NOTE: This routine ignores indices for dimensions that do not exist in the wave.		You should pass in value[0] the real part of the value.	If the wave is complex, you should pass the complex part in value[1].	If the wave is not complex, Igor ignores value[1].		The function result is 0 or an error code.	Currently the only error code returned is MD_WAVE_BAD_INDEX, indicating	that you have passed invalid indices. Future versions of Igor may return	other error codes. If you receive an error, just return it to Igor so	that it will be reported to the user.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDSetNumericWavePointValue(waveHndl wavH, long indices[MAX_DIMENSIONS], double value[2]){	long index;	int result;	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			index = indices[0];			return StoreNumericValue((*(WaveHandle2)wavH)->type, (char*)(*(WaveHandle2)wavH)->wData, index, value);			break;				case kWaveStruct3Version:			if (result = MDPointIndex1((WaveHandle3)wavH, indices, &index))				return result;			return StoreNumericValue((*(WaveHandle3)wavH)->type, (char*)(*(WaveHandle3)wavH)->wData, index, value);			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack3(MD_SETWAVEPOINTVALUE, wavH, indices, value));			break;	}}/*	MDGetDPDataFromNumericWave(wavH, dPtr)		MDGetDPDataFromNumericWave stores a double-precision representation of	the specified wave's data in the memory pointed to by dPtr. dPtr must	point to a block of memory that you have allocated and which must be	at least (WavePoints(wavH)*sizeof(double)) bytes.		This routine is intended for use with MDStoreDPDataInNumericWave.		The function result is zero or an error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDGetDPDataFromNumericWave(waveHndl wavH, double* dPtr){	long numNumbers, bytesPerPoint;	int type, type2;	int srcFormat;	int hState;		switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:		case kWaveStruct3Version:			type = WaveType(wavH);			type2 = type & ~NT_CMPLX;			if (type2==TEXT_WAVE_TYPE)				return NUMERIC_ACCESS_ON_TEXT_WAVE;			switch(type2) {				case NT_I8:					bytesPerPoint = sizeof(char);					srcFormat = SIGNED_INT;					break;				case NT_I8 | NT_UNSIGNED:					bytesPerPoint = sizeof(char);					srcFormat = UNSIGNED_INT;					break;				case NT_I16:					bytesPerPoint = sizeof(short);					srcFormat = SIGNED_INT;					break;				case NT_I16 | NT_UNSIGNED:					bytesPerPoint = sizeof(short);					srcFormat = UNSIGNED_INT;					break;				case NT_I32:					bytesPerPoint = sizeof(long);					srcFormat = SIGNED_INT;					break;				case NT_I32 | NT_UNSIGNED:					bytesPerPoint = sizeof(long);					srcFormat = UNSIGNED_INT;					break;				case NT_FP32:					bytesPerPoint = sizeof(float);					srcFormat = IEEE_FLOAT;					break;				case NT_FP64:					bytesPerPoint = sizeof(double);					srcFormat = IEEE_FLOAT;					break;				default:					return WAVE_TYPE_INCONSISTENT;		/* Corrupted wave. */			}			numNumbers = WavePoints(wavH);			if (type & NT_CMPLX)				numNumbers *= 2;			hState = MoveLockHandle(wavH);			ConvertData(WaveData(wavH), dPtr, numNumbers, bytesPerPoint, srcFormat, sizeof(double), IEEE_FLOAT);			HSetState(wavH, hState);			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack2(MD_GETDPDATAFROMNUMERICWAVE, wavH, dPtr));			break;	}	return 0;}/*	MDStoreDPDataInNumericWave(wavH, dPtr)		MDStoreDPDataInNumericWave stores the data pointed to by dPtr in the specified wave.	During the transfer, it converts the data from double precision to the numeric type	of the wave. The conversion is done on-the-fly and the data pointed to by dPtr is not	changed.		This routine is intended for use with MDGetDPDataInNumericWave.		The function result is zero or an error code.		Added in Igor Pro 3.0 but works with all supported versions (>= 1.24).*/intMDStoreDPDataInNumericWave(waveHndl wavH, double* dPtr){	long numNumbers, bytesPerPoint;	int type, type2;	int destFormat;	int hState;		switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:		case kWaveStruct3Version:			type = WaveType(wavH);			type2 = type & ~NT_CMPLX;			if (type2==TEXT_WAVE_TYPE)				return NUMERIC_ACCESS_ON_TEXT_WAVE;			switch(type2) {				case NT_I8:					bytesPerPoint = sizeof(char);					destFormat = SIGNED_INT;					break;				case NT_I8 | NT_UNSIGNED:					bytesPerPoint = sizeof(char);					destFormat = UNSIGNED_INT;					break;				case NT_I16:					bytesPerPoint = sizeof(short);					destFormat = SIGNED_INT;					break;				case NT_I16 | NT_UNSIGNED:					bytesPerPoint = sizeof(short);					destFormat = UNSIGNED_INT;					break;				case NT_I32:					bytesPerPoint = sizeof(long);					destFormat = SIGNED_INT;					break;				case NT_I32 | NT_UNSIGNED:					bytesPerPoint = sizeof(long);					destFormat = UNSIGNED_INT;					break;				case NT_FP32:					bytesPerPoint = sizeof(float);					destFormat = IEEE_FLOAT;					break;				case NT_FP64:					bytesPerPoint = sizeof(double);					destFormat = IEEE_FLOAT;					break;				default:					return WAVE_TYPE_INCONSISTENT;		/* Corrupted wave. */			}			numNumbers = WavePoints(wavH);			if (type & NT_CMPLX)				numNumbers *= 2;			hState = MoveLockHandle(wavH);			ConvertData(dPtr, WaveData(wavH), numNumbers, sizeof(double), IEEE_FLOAT, bytesPerPoint, destFormat);			HSetState(wavH, hState);			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack2(MD_STOREDPDATAINNUMERICWAVE, wavH, dPtr));			break;	}	return 0;}/*	DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT		HR, 5/20/95		I found that it was not significantly slower to call back to Igor for		getting or setting a text wave point value. A test on 8000 data points		took 14.2 seconds calling back to Igor and 13.5 seconds done locally.		This was on a PowerMac 7100/66.				Therefore, I have omitted the code that would do this locally and always		call back to Igor. The advantage of this is that, if Igor changes the storage		organization for text waves, there will be no compatibility problems.*/#define DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT 0#if DO_TEXTWAVE_GET_SET_IN_XOPSUPPORTstatic intMDFetchWaveTextValue(WaveHandle3 wavH, long index, Handle textH){	long p0,p1;			// starting and ending index value	long length;	long **sIndices;	if ((*wavH)->type != TEXT_WAVE_TYPE)		return TEXT_ACCESS_ON_NUMERIC_WAVE;	if ((*wavH)->numPoints==0)		return MD_WAVE_BAD_INDEX;		if (index < 0)		index = 0;	if (index >= (*wavH)->numPoints)		index= (*wavH)->numPoints-1;		sIndices= (*wavH)->sIndices;	if (sIndices == NIL)		return NOMEM;			/* should never happen */		if (index == 0)		p0 = 0;	else		p0 = (*sIndices)[index-1];	p1 = (*sIndices)[index];	length = p1 - p0;		SetHandleSize(textH, length);	if (MemError())		return NOMEM;		memcpy(*textH, (char *)&(*wavH)->wData[0]+p0, length);	return 0;}#endif	/* DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT *//*	MDGetTextWavePointValue(wavH, indices, textH)		Returns via textH the value of a particular point in the specified wave.	Any previous contents of textH are overwritten.		If the wave is not a text wave, returns an error code and does not	alter textH.		indices is an array of dimension indices. For example, for a 3D wave,		indices[0] should contain the row number		indices[1] should contain the column number		indices[2] should contain the layer number		NOTE: This routine ignores indices for dimensions that do not exist in the wave.		You must create textH before calling MDGetTextWavePointValue.	For example:		textH = NewHandle(0L);		On output, if there is no error, textH contains a copy of the characters	in the specified wave point. A point in an Igor text wave can contain	any number of characters, including zero. Therefore, the handle can	contain any number of characters. Igor text waves can contain any characters,	including control characters. No characters codes are considered illegal.		The characters in the handle are not null terminated. If you want	to treat them as a C string, you should add a null character at the end.	Make sure to remove any null termination if you pass the handle back to Igor.			The function result is 0 or an error code.		Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no text waves.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intMDGetTextWavePointValue(waveHndl wavH, long indices[MAX_DIMENSIONS], Handle textH){#if DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT	long index;	int result;	switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return IGOR_OBSOLETE;	/* This version of the wave structure did not support text waves. */			break;				case kWaveStruct3Version:			if (result = MDPointIndex1((WaveHandle3)wavH, indices, &index))				return result;			return MDFetchWaveTextValue((WaveHandle3)wavH, index, textH);			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack3(MD_GETTEXTWAVEPOINTVALUE, wavH, indices, textH));			break;	}#else	return(CallBack3(MD_GETTEXTWAVEPOINTVALUE, wavH, indices, textH));#endif /* DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT */}#if DO_TEXTWAVE_GET_SET_IN_XOPSUPPORTstatic intMDStoreWaveTextValue(WaveHandle3 wavH, long index, Handle textH){	char *data;	long **sIndices,*iPtr;	long p0,p1,pn;			// starting and ending index value and last index value (total chars)	long numPoints,oldSLen,newSLen,difSLen,i;	int err;	if ((*wavH)->type != TEXT_WAVE_TYPE)		return TEXT_ACCESS_ON_NUMERIC_WAVE;		if (textH == NULL)		return 0;					// do nothing if null source handle		sIndices= (*wavH)->sIndices;	if (sIndices == NIL)		return NOMEM;				/* Should never happen. */		if (index < 0)		index = 0;	if (index >= (*wavH)->numPoints)		index = (*wavH)->numPoints-1;	if (index == 0)		p0 = 0;	else		p0 = (*sIndices)[index-1];	p1 = (*sIndices)[index];		numPoints = (*wavH)->numPoints;	pn = (*sIndices)[numPoints-1];	oldSLen = p1-p0;	newSLen = GetHandleSize(textH);	difSLen = newSLen-oldSLen;	err = 0;	if (difSLen <= 0) {									/* shrinking or staying the same? */		data= (char *)&(*wavH)->wData[0];				/* DEREFERENCE */		memmove(data+p1+difSLen, data+p1, pn-p1);		/* shift down */		SetHandleSize((Handle)wavH,GetHandleSize((Handle)wavH)+difSLen);	}	else {		SetHandleSize((Handle)wavH,GetHandleSize((Handle)wavH)+difSLen);		err = MemError();		if (err == 0){			data= (char *)&(*wavH)->wData[0];			/* DEREFERENCE */			memmove(data+p1+difSLen, data+p1, pn-p1);	/* shift up */		}	}	if (err == 0) {		data= (char *)&(*wavH)->wData[0];				/* DEREFERENCE */		memcpy(data+p0, *textH, newSLen);				/* install new string */		iPtr= (*sIndices + index);						/* DEREFERENCE */		for(i=index;i<numPoints;i++)			*iPtr++ += difSLen;							/* update indices */	}		return err;}#endif /* DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT *//*	MDSetTextWavePointValue(wavH, indices, textH)		Transfers the characters in textH to the specified point in the specified	wave. The contents of textH is not altered.		If the wave is not a text wave, returns an error code.		indices is an array of dimension indices. For example, for a 3D wave,		indices[0] should contain the row number		indices[1] should contain the column number		indices[2] should contain the layer number		NOTE: This routine ignores indices for dimensions that do not exist in the wave.		A point in an Igor text wave can contain any number of characters, including zero.	Therefore, the handle can contain any number of characters. Igor text waves can	contain any characters, including control characters. No characters codes are	considered illegal.		The characters in the handle should not null terminated. If you have	put a null terminator in the handle, remove it before calling MDSetTextWavePointValue.		After calling MDSetTextWavePointValue, the handle is still yours so	you should dispose it when you no longer need it.			The function result is 0 or an error code.		Added in Igor Pro 3.0. Prior to Igor Pro 3.0, there were no text waves.	Therefore, if you call this when running with an earlier version, you will	receive an error code as the function result.*/intMDSetTextWavePointValue(waveHndl wavH, long indices[MAX_DIMENSIONS], Handle textH){#if DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT	long index;	int result;		switch(WAVE_VERSION(wavH)) {		case kWaveStruct2Version:			return IGOR_OBSOLETE;	/* This version of the wave structure did not support text waves. */			break;				case kWaveStruct3Version:			if (result = MDPointIndex1((WaveHandle3)wavH, indices, &index))				return result;			return MDStoreWaveTextValue((WaveHandle3)wavH, index, textH);			break;				default:		/* Future version of Igor with a different wave structure. */			return(CallBack3(MD_SETTEXTWAVEPOINTVALUE, wavH, indices, textH));			break;	}#else	return(CallBack3(MD_SETTEXTWAVEPOINTVALUE, wavH, indices, textH));#endif /* DO_TEXTWAVE_GET_SET_IN_XOPSUPPORT */}/*	GetTextWaveData(waveH, mode, textDataHPtr)	Returns all of the text for the specified text wave via textDataHPtr.		NOTE: This routine is for advanced programmers who are comfortable with	pointer arithmetic and handles. Less experienced programmers should use	MDGetTextWavePointValue to get the wave text values one at a time.		If the function result is 0 then *textDataHPtr is a handle that you own.	When you are finished, dispose of it using DisposeHandle.		In the event of an error, the function result will be non-zero and	*textDataHPtr will be NULL.		The returned handle will contain the text for all of the wave's elements	in one of several formats explained below. The format depends on the mode	parameter.		Modes 0 and 1 use a null byte to mark the end of a string and thus	will not work if 0 is considered to be a legal character value.	mode = 0		The returned handle contains one C string (null-terminated) for each element		of the wave.		Example:			"Zero"<null>			"One"<null>			"Two"<null>		mode = 1		The returned handle contains a list of 32-bit offsets to strings followed		by the string data. There is one extra offset which is the offset		to where the string would be for the next element if the wave had one		more element.				The text for each element in the wave is represented by a C string (null-terminated).				Example:			<Offset to "Zero">			<Offset to "One">			<Offset to "Two">			<Extra offset>			"Zero"<null>			"One"<null>			"Two"<null>		mode = 2		The returned handle contains a list of 32-bit offsets to strings followed		by the string data.	There is one extra offset which is the offset		to where the string would be for the next element if the wave had one		more element.				The text for each element in the wave is not null-terminated.				Example:			<Offset to "Zero">			<Offset to "One">			<Offset to "Two">			<Extra offset>			"Zero"			"One"			"Two"				Using modes 1 and 2, you can determine the length of element i by subtracting	offset i from offset i+1.		You can convert the offsets into pointers to strings by adding	**textDataHPtr to each of the offsets. However, since the handle in	theory can be relocated in memory, you should lock the handle before	converting to pointers and unlock it when you are done with it.		For the purposes of GetTextWaveData, the wave is treated as a 1D wave	regardless of its true dimensionality. If waveH a 2D text wave, the	data returned via textDataHPtr is in column-major order. This means that	the data for each row of the first column appears first in memory, followed	by the data for the each row of the next column, and so on.			Returns 0 or an error code.		For an example using this routine, see TestGetAndSetTextWaveData below.		Added for Igor Pro 5.04. If you call this with an earlier version of Igor,	it will return IGOR_OBSOLETE and do nothing.*/intGetTextWaveData(waveHndl waveH, int mode, Handle* textDataHPtr){	return(CallBack3(GET_TEXT_WAVE_DATA, waveH, (void*)mode, textDataHPtr));}/*	SetTextWaveData(waveH, mode, textDataH)	Sets all of the text for the specified text wave according to textDataH.		NOTE: This routine is for advanced programmers who are comfortable with	pointer arithmetic and handles. Less experienced programmers should use	MDSetTextWavePointValue to set the wave text values one at a time.		WARNING: If you pass inconsistent data in textDataH you will cause Igor to crash.		SetTextWaveData can not change the number of points in the text wave.	Therefore the data in textDataH must be consistent with the number of	points in text wave. Otherwise a crash will occur.	Also, when using modes 1 or 2, the offsets must be correct. Otherwise a	crash will occur.		Crashes caused by inconsistent data may occur at unpredictable times making	it hard to trace it to the problem. So triple-check your code.		You own the textDataH handle. When you are finished with it, dispose of it	using DisposeHandle.		The format of textDataH depends on the mode parameter. See the documentation	for GetTextWaveData for a description of these formats.		Modes 0 and 1 use a null byte to mark the end of a string and thus	will not work if 0 is considered to be a legal character value.			Returns 0 or an error code.		For an example using this routine, see TestGetAndSetTextWaveData below.		Added for Igor Pro 5.04. If you call this with an earlier version of Igor,	it will return IGOR_OBSOLETE and do nothing.*/intSetTextWaveData(waveHndl waveH, int mode, Handle textDataH){	return(CallBack3(SET_TEXT_WAVE_DATA, waveH, (void*)mode, textDataH));}/*	TestGetAndSetTextWaveData(sourceWaveH, destWaveH, mode, echo)	This routine is here just to give you and example of using GetTextWaveData	and SetTextWaveData.		If echo is true the contents of the source wave are printed in the history area.	Then the data from the source wave is copied to the dest wave.*/static intTestGetAndSetTextWaveData(waveHndl sourceWaveH, waveHndl destWaveH, int mode, int echo){	Handle textDataH;	long npnts;	long* pTableOffset;	char* pTextData;	char message[256];	int dataLen, prefixLen, availableBytes;	int i;	int err;		if (WaveType(sourceWaveH) != TEXT_WAVE_TYPE)		return TEXT_ACCESS_ON_NUMERIC_WAVE;		if (WaveType(destWaveH) != TEXT_WAVE_TYPE)		return TEXT_ACCESS_ON_NUMERIC_WAVE;		npnts = WavePoints(sourceWaveH);		if (err = ChangeWave(destWaveH, npnts, TEXT_WAVE_TYPE))		return err;		if (err = GetTextWaveData(sourceWaveH, mode, &textDataH))		return err;			MoveLockHandle(textDataH);	pTableOffset = (long*)*textDataH;					// Pointer to table of offsets if mode==1 or mode==2	pTextData = *textDataH;	if (mode > 0)		pTextData += (npnts+1) * sizeof(long);			for(i=0; i<npnts; i+=1) {		switch(mode) {			case 0:				dataLen = strlen(pTextData);				break;						case 1:				dataLen = pTableOffset[i+1] - pTableOffset[i];				dataLen -= 1;							// Exclude null terminator.				break;			case 2:				dataLen = pTableOffset[i+1] - pTableOffset[i];				break;			}		if (echo) {			sprintf(message, "Element %d: ", i);			prefixLen = strlen(message);			availableBytes = sizeof(message) - prefixLen - 1 - 1;		// Allow 1 for CR and 1 for null terminator.			if (dataLen > availableBytes)				dataLen = availableBytes;			memcpy(message+prefixLen, pTextData, dataLen);			message[prefixLen + dataLen] = 0x0D;			message[prefixLen + dataLen+1] = 0;			XOPNotice(message);		}				switch(mode) {			case 0:				pTextData += dataLen + 1;				break;						case 1:				pTextData += dataLen + 1;				break;			case 2:				pTextData += dataLen;				break;			}			}		HUnlock(textDataH);		err = SetTextWaveData(destWaveH, mode, textDataH);	DisposeHandle(textDataH);	return err;}/*	GetWaveDimensionLabels(waveH, dimLabelsHArray)	dimLabelsHArray points to an array of MAX_DIMENSIONS handles. GetWaveDimensionLabels	sets each element of this array to a handle containing dimension labels or to NULL.		On output, if the function result is 0 (no error), dimLabelsHArray[i] will be a	handle containing dimension labels for dimension i or NULL if dimension i has no	dimension labels.		If the function result is non-zero then all handles in dimLabelsHArray will be NULL.		Any non-NULL output handles belong to you. Dispose of them with DisposeHandle	when you are finished with them.		For each dimension, the corresponding dimension label handle consists of	an array of N+1 C strings, each in a field of (MAX_DIM_LABEL_CHARS+1) bytes.		The first label is the overall dimension label for that dimension.		Label i+1 is the dimension label for element i of the dimension.		N is the smallest number such that the last non-empty dimension label	for a given dimension and all dimension labels before it, whether empty	or not, can be stored in the handle.		For example, if a 5 point 1D wave has dimension labels for rows 0 and 2	with all other dimension labels being empty then dimLabelsHArray[0] will	contain four dimension labels, one for the overall dimension and three	for rows 0 through 2. dimLabelsHArray[0] will not contain any storage	for any point after row 2 because the remaining dimension labels for	that dimension are empty.			Returns 0 or an error code.		For an example using this routine, see TestGetAndSetWaveDimensionLabels below.		Added for Igor Pro 5.04. If you call this with an earlier version of Igor,	it will return IGOR_OBSOLETE and do nothing.*/intGetWaveDimensionLabels(waveHndl waveH, Handle dimLabelsHArray[MAX_DIMENSIONS]){	return(CallBack2(GET_WAVE_DIMENSION_LABELS, waveH, dimLabelsHArray));}/*	SetWaveDimensionLabels(waveH, dimLabelsHArray)	dimLabelsHArray points to an array of MAX_DIMENSIONS handles. SetWaveDimensionLabels	sets the dimension labels for each existing dimension of waveH based on the	corresponding handle in dimLabelsHArray.		The handles in dimLabelsHArray belong to you. Dispose of them with DisposeHandle	when you are finished with them.		See the documentation for GetWaveDimensionLabels for a discussion of how	the dimension labels are stored in the handles.			Returns 0 or an error code.		For an example using this routine, see TestGetAndSetWaveDimensionLabels below.		Added for Igor Pro 5.04. If you call this with an earlier version of Igor,	it will return IGOR_OBSOLETE and do nothing.*/intSetWaveDimensionLabels(waveHndl waveH, Handle dimLabelsHArray[MAX_DIMENSIONS]){	return(CallBack2(SET_WAVE_DIMENSION_LABELS, waveH, dimLabelsHArray));}/*	TestGetAndSetWaveDimensionLabels(sourceWaveH, destWaveH, echo)	This routine is here just to give you and example of using GetWaveDimensionLabels	and SetWaveDimensionLabels.		If echo is true the source wave's dimension labels are printed in the history area.		Then the dimension labels are copied from the source to the dest wave.*/static intTestGetAndSetWaveDimensionLabels(waveHndl sourceWaveH, waveHndl destWaveH, int echo){	Handle dimLabelsH;	long numDimensions;	long dimensionSizes[MAX_DIMENSIONS+1];	long numLabels, element;	int dim;	Handle dimLabelsHArray[MAX_DIMENSIONS];	char label[MAX_DIM_LABEL_CHARS+1];	char message[256];	int err;		if (err = MDGetWaveDimensions(sourceWaveH, &numDimensions, dimensionSizes))		return err;		if (err = MDChangeWave(destWaveH, WaveType(destWaveH), dimensionSizes))		return err;		if (err = GetWaveDimensionLabels(sourceWaveH, dimLabelsHArray))		return err;			if (echo) {		for(dim=0; dim<numDimensions; dim+=1) {			dimLabelsH = dimLabelsHArray[dim];			if (dimLabelsH == NULL) {				sprintf(message, "Dimension %d has no labels"CR_STR, dim);				XOPNotice(message);			}			else {				numLabels = GetHandleSize(dimLabelsH) / (MAX_DIM_LABEL_CHARS+1);				for(element=-1; element<(numLabels-1); element++) {					strcpy(label, *dimLabelsH + (element+1)*(MAX_DIM_LABEL_CHARS+1));					sprintf(message, "Dimension %d, element %ld = '%s'"CR_STR, dim, element, label);					XOPNotice(message);								}			}		}	}			err = SetWaveDimensionLabels(destWaveH, dimLabelsHArray);	// We own the label handles and thus must dispose of them.	for(dim=0; dim<numDimensions; dim+=1) {		dimLabelsH = dimLabelsHArray[dim];		if (dimLabelsH != NULL)			DisposeHandle(dimLabelsH);	}		return err;}#include "XOPStructureAlignmentReset.h"	// Reset structure alignment to default.